[
["index.html", "Analysis of single-cell RNA-seq data 1 About the course 1.1 Registration 1.2 GitHub 1.3 License 1.4 Prerequisites 1.5 Contact", " Analysis of single-cell RNA-seq data Vladimir Kiselev, Tallulah Andrews, Davis McCarthy and Martin Hemberg 2016-06-22 1 About the course Recent technological advances have made it possible to obtain genome-wide transcriptome data from single cells using high-throughput sequencing (scRNA-seq). The main advantage of scRNA-seq is that the cellular resolution and the genome wide scope makes it possible to address issues that are intractable using other methods, e.g. bulk RNA-seq or single-cell RT-qPCR. However, to analyze scRNA-seq data, novel methods are required and some of the underlying assumptions for the methods developed for bulk RNA-seq experiments are no longer valid. In this course we will be surveying the existing problems as well as the available computational and statistical frameworks available for the analysis of scRNA-seq. The course is taught through the University of Cambridge Bioinformatics training unit, but the material found on these pages is meant to be used for anyone interested in learning about computational analysis of scRNA-seq data. 1.1 Registration http://training.csx.cam.ac.uk/bioinformatics/event/1755391 1.2 GitHub https://github.com/hemberg-lab/scRNA.seq.course 1.3 License Creative Commons Attribution-NoDerivatives 4.0 International License 1.4 Prerequisites The course is intended for those who have basic familiarity with Unix and the R scripting language. We will also assume that you are familiar with mapping and analysing bulk RNA-seq data as well as with the commonly available computational tools. We recommend attending the Introduction to RNA-seq and ChIP-seq data analysis or the Analysis of high-throughput sequencing data with Bioconductor before attending this course. 1.5 Contact If you have any comments, questions or suggestions about the material, please contact Vladimir Kiselev. "],
["technical-requirements.html", "2 Technical requirements 2.1 General 2.2 Plotting 2.3 QC and normalisation 2.4 Clustering 2.5 Dropouts 2.6 Pseudotime 2.7 Differential Expression", " 2 Technical requirements This course is based on the popular programming language R. However, one of the methods that we describe (SNN-Cliq) is only partly R-based. It makes a simple python call from R and requires a user to have write permissions to the working directory. To be able to run all code chunks of the course one needs to clone or download the course GitHub repository and start an R session in the cloned folder. One also needs to install the following R packages (ordered by purposes): 2.1 General devtools for installing packages from GitHub: install.packages(&quot;devtools&quot;) BiocInstaller for installing packages from BioConductor: source(&#39;https://bioconductor.org/biocLite.R&#39;) biocLite(&#39;BiocInstaller&#39;) scRNA.seq.funcs - R package containing some special functions used in this course: devtools::install_github(&quot;hemberg-lab/scRNA.seq.funcs&quot;) 2.2 Plotting ggplot2 for plotting general plots: install.packages(&quot;ggplot2&quot;) pheatmap for plotting heatmaps: install.packages(&quot;pheatmap&quot;) limma for plotting Venn diagrams: ## try http:// if https:// URLs are not supported source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;limma&quot;) 2.3 QC and normalisation scater is a single-cell analysis toolkit for expression: source(&#39;https://bioconductor.org/biocLite.R&#39;) biocLite(&#39;scater&#39;) mvoutlier - for an automatic outlier detection used by the scater package. install.packages(&quot;mvoutlier&quot;) statmod - a dependency for mvoutlier. install.packages(&quot;statmod&quot;) Rtsne for Rtsne data embedding: install.packages(&quot;Rtsne&quot;) scran for a new single cell normalisation method (LSF): source(&#39;https://bioconductor.org/biocLite.R&#39;) biocLite(&#39;scran&#39;) RUVSeq for normalization using ERCC controls: ## try http:// if https:// URLs are not supported source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;RUVSeq&quot;) 2.4 Clustering pcaReduce for unsupervised clustering of scRNA-seq data (bioRxiv): devtools::install_github(&quot;JustinaZ/pcaReduce&quot;) pcaMethods is a pcaReduce dependency: ## try http:// if https:// URLs are not supported source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;pcaMethods&quot;) SC3 for unsupervised clustering of scRNA-seq data: source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;SC3&quot;) Before running SC3 for the first time only, please start R and enter: RSelenium::checkForServer() SEURAT for density clustering of scRNA-seq data: devtools::install_github(&#39;Puriney/seurat&#39;) 2.5 Dropouts M3Drop for identification of important and DE genes: devtools::install_github(&quot;tallulandrews/M3D&quot;) 2.6 Pseudotime TSCAN for pseudotime analysis: ## try http:// if https:// URLs are not supported source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;TSCAN&quot;) monocle for pseudotime analysis: ## try http:// if https:// URLs are not supported source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;monocle&quot;) 2.7 Differential Expression ROCR for performance estimations: install.packages(&quot;ROCR&quot;) DESeq2 for identification of differentially expressed genes: ## try http:// if https:// URLs are not supported source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;DESeq2&quot;) scde for identification of differentially expressed genes: devtools::install_github(&quot;hms-dbmi/scde&quot;, build_vignettes = FALSE) Installation on Mac OS X may require this additional gfortran library: curl -O http://r.research.att.com/libs/gfortran-4.8.2-darwin13.tar.bz2 sudo tar fvxz gfortran-4.8.2-darwin13.tar.bz2 -C / See the help page for additional support. "],
["introduction-to-single-cell-rna-seq.html", "3 Introduction to single-cell RNA-seq 3.1 Bulk RNA-seq 3.2 scRNA-seq 3.3 Protocol 3.4 Computational Analysis 3.5 Challenges 3.6 Controls", " 3 Introduction to single-cell RNA-seq 3.1 Bulk RNA-seq A major breakthrough (replaced microarrays) in the late 00’s and has been widely used since Measures the average expression level for each gene across a large population of input cells Useful for comparative transcriptomics, e.g. samples of the same tissue from different species Useful for quantifying expression signatures from ensembles, e.g. in disease studies Insufficient for studying heterogeneous systems, e.g. early development studies, complex tissues (brain) Does not provide insights into the stochastic nature of gene expression 3.2 scRNA-seq A new technology, first publication by (Tang et al. 2009) Measures the distribution of expression levels for each gene across a population of cells Allows to study new biological questions in which cell-specific changes in transcriptome are important, e.g. cell type identification, heterogeneity of cell responses, stochasticity of gene expression, inference of gene regulatory networks across the cells. Datasets range from \\(10^2\\) to \\(10^4\\) cells and increase in size every year Currently there are several different protocols in use, e.g. SMART-seq2 (Picelli et al. 2013), CELL-seq (Hashimshony et al. 2012) and Drop-seq (Macosko et al. 2015) Several computational analysis methods from bulk RNA-seq can be used In most cases computational analysis requires adaptation of the existing methods or development of new ones 3.3 Protocol Figure 3.1: Single cell sequencing (taken from here) Overall, experimental scRNA-seq protocols are similar to the methods used for bulk RNA-seq. For a discussion on experimental methods, please see reviews by (Saliba et al. 2014), (Handley et al. 2015) or (Kolodziejczyk et al. 2015). 3.4 Computational Analysis This course is concerned with the computational analysis of the data obtained from scRNA-seq experiments. The first steps (yellow) are general for any highthroughput sequencing data. Later steps (orange) require a mix of existing RNASeq analysis methods and novel methods to address the technical difference of scRNASeq. Finally the biological interpretation should be analyzed with methods specifically developed for scRNASeq. Figure 3.2: Flowchart of the scRNA-seq analysis There are several reviews of the scRNA-seq analysis available including (Stegle, Teichmann, and Marioni 2015). 3.5 Challenges The main difference between bulk and single cell RNA-seq is that each sequencing library represents a single cell, instead of a population of cells. Therefore, significant attention has to be paid to comparison of the results from different cells (sequencing libraries). The main sources of discrepancy between the libraries are: Amplification (up to 1 million fold) Gene ‘dropouts’ in which a gene is observed at a moderate expression level in one cell but is not detected in another cell (Kharchenko, Silberstein, and Scadden 2014). In both cases the discrepancies are introduced due to low starting amounts of transcripts since the RNA comes from one cell only. Improving the transcript capture efficiency and reducing the amplification bias are currently active areas of research. 3.6 Controls To provide better estimates of the technical variation between scRNA sequencing libraries two quantitative standards are frequently used. The aim of using spike-ins and UMIs is to facilitate normalization of gene expression levels across different cells. 3.6.1 Spike-ins Spike-ins are extrinsic RNA molecules of known concentration which are added to the lysate of each cell prior to the reverse transcription reaction. The most popular and widely used spike-ins are synthetic spikes from the External RNA Control Consortium (ERCC). This set of 96 synthetic mRNAs of differing length and GC content based on bacterial sequences (Jiang et al. 2011). 3.6.2 UMIs Another method of standardisation is to use Unique Molecular Identifiers (UMIs) (Kivioja et al. 2012). These are 4-20 bp barcode sequences which are added to the 3’ or 5’ end of each transcript prior to amplification (typically during reverse transcription). This is usually followed by targetted sequencing of the respective end of the transcripts. The barcodes make it possible to quantify the number of transcripts prior to the amplification step. References "],
["construction-of-expression-matrix.html", "4 Construction of expression matrix 4.1 Reads QC 4.2 Reads alignment 4.3 Alignment example 4.4 Mapping QC 4.5 Reads quantification", " 4 Construction of expression matrix 4.1 Reads QC The output from a scRNA-seq experiment is a large collection of cDNA reads. The first step is to ensure that the reads are of high quality. The quality control can be performed by using standard tools, such as FastQC or Kraken. Assuming that our reads are in experiment.bam, we run FastQC as $&lt;path_to_fastQC&gt;/fastQC experiment.bam Below is an example of the output from FastQC for a dataset of 125 bp reads. The plot reveals a technical error which resulted in a couple bases failing to be read correctly in the centre of the read. However, since the rest of the read was of high quality this error will most likely have a negligible effect on mapping efficiency. Figure 4.1: Example of FastQC output Additionally, it is often helpful to visualize the data using the Integrative Genomics Browser (IGV) or SeqMonk. 4.2 Reads alignment After trimming low quality bases from the reads, the remaining sequences can be mapped to a reference genome. Again, there is no need for a special purpose method for this, so we can use the STAR or the TopHat aligner. An example of how to map reads.bam to using STAR is $&lt;path_to_STAR&gt;/STAR --runThreadN 1 --runMode alignReads --readFilesIn reads1.fq.gz reads2.fq.gz --readFilesCommand zcat --genomeDir &lt;path&gt; --parametersFiles FileOfMoreParameters.txt --outFileNamePrefix &lt;outpath&gt;/output Note, if the spike-ins are used, the reference sequence should be augmented with the DNA sequence of the spike-in molecules prior to mapping. Note, when UMIs are used, their barcodes should be removed from the read sequence. A common practice is to add the barcode to the read name. Once the reads for each cell have been mapped to the reference genome, we need to make sure that a sufficient number of reads from each cell could be mapped to the reference genome. In our experience, the fraction of mappable reads for mouse or human cells is 60-70%. However, this result may vary depending on protocol, read length and settings for the read alignment. As a general rule, we expect all cells to have a similar fraction of mapped reads, so any outliers should be inspected and possibly removed. A low proportion of mappable reads usually indicates contamination. 4.3 Alignment example The histogram below shows the total number of reads mapped to each cell for an scRNA-seq experiment. Each bar represents one cell, and they have been sorted in ascending order by the total number of reads per cell. The three red arrows indicate cells that are outliers in terms of their coverage and they should be removed from further analysis. The two yellow arrows point to cells with a surprisingly large number of unmapped reads. In this example we kept the cells during the alignment QC step, but they were later removed during cell QC due to a high proportion of ribosomal RNA reads. Figure 4.2: Example of the total number of reads mapped to each cell. 4.4 Mapping QC After mapping the raw sequencing to the genome we need to evaluate the quality of the mapping. There are many ways to measure the mapping quality, including: amount of reads mapping to rRNA/tRNAs, proportion of uniquely mapping reads, reads mapping across splice junctions, read depth along the transcripts. Methods developed for bulk RNA-seq, such as RSeQC, are applicable to single-cell data: python &lt;RSeQCpath&gt;/geneBody_coverage.py -i input.bam -r genome.bed -o output.txt python &lt;RSeQCpath&gt;/bam_stat.py -i input.bam -r genome.bed -o output.txt python &lt;RSeQCpath&gt;/split_bam.py -i input.bam -r rRNAmask.bed -o output.txt However the expected results will depend on the experimental protocol, e.g. many scRNA-seq methods use poly-A selection to avoid sequencing rRNAs which results in a 3’ bias in the read coverage across the genes (aka gene body coverage). The figure below shows this 3’ bias as well as three cells which were outliers and removed from the dataset: Figure 4.3: Example of the 3’ bias in the read coverage. 4.5 Reads quantification The next step is to quantify the expression level of each gene for each cell. For mRNA data, we can use one of the tools which has been developed for bulk RNA-seq data, e.g. HT-seq or FeatureCounts # include multimapping &lt;featureCounts_path&gt;/featureCounts -O -M -Q 30 -p -a genome.gtf -o outputfile input.bam # exclude multimapping &lt;featureCounts_path&gt;/featureCounts -Q 30 -p -a genome.gtf -o outputfile input.bam 4.5.1 UMI quantification The number of unique barcodes used as UMIs is typically much smaller than the total number of mRNAs in a cell. Thus to properly count UMIs they must be separated into groups based on their mapping position. Most scRNASeq methods perform several rounds of PCR prior to fragmenting transcripts. As a result UMIs originating from the same mRNA won’t map to exactly the same position in the genome. Thus UMIs should be grouped by transcript or gene. One way to achieve this is to map reads to the transcriptome rather than the genome. Once UMIs have been grouped the number of original mRNA molecules can be estimated by counting the number of unique UMIs in each group. However, single base-pair substitutions introduced by errors during PCR or sequencing can create “new” unique UMIs inflating the counts. This effect depends on the length of the barcode used, longer = more potential errors. For instance using a 10bp barcode will result in ~7% of reads containing at least one error. To our knowledge the only software which attempts to correct for these errors is UMI-tools. They provide several different methods to quantify UMIs based on different assumptions about what type of errors occur in the barcodes (they discuss them in detail here). "],
["scater-package.html", "5 scater package 5.1 Introduction 5.2 scater workflow 5.3 Terminology 5.4 SCESet class", " 5 scater package 5.1 Introduction scater is a R package single-cell RNA-seq analysis. The package contains several useful methods for quality control, visualisation and pre-processing of data prior to further downstream analysis. scater features the following functionality: Automated computation of QC metrics Transcript quantification from read data with pseudo-alignment Data format standardisation Rich visualizations for exploratory analysis Seamless integration into the Bioconductor universe Simple normalisation methods We highly recommend to use scater for all single-cell RNA-seq analyses and scater is the basis of the first part of the course. 5.2 scater workflow 5.3 Terminology (this chapter is taken from the scater vignette) The capabilities of scater are built on top of Bioconductor’s Biobase. In Bioconductor terminology we assay numerous “features” for a number of “samples”. Features, in the context of scater, correspond most commonly to genes or transcripts, but could be any general genomic or transcriptomic regions (e.g. exon) of interest for which we take measurements. In the following chapters it may be more intuitive to mentally replace “feature” with “gene” or “transcript” (depending on the context of the study) wherever “feature” appears. In the scater context, “samples” refer to individual cells that we have assayed. 5.4 SCESet class (this chapter is taken from the scater vignette) In scater we organise single-cell expression data in objects of the SCESet class. The class inherits the Bioconductor ExpressionSet class, which provides a common interface familiar to those who have analyzed microarray experiments with Bioconductor. The class requires three input files: exprs, a numeric matrix of expression values, where rows are features, and columns are cells phenoData, an AnnotatedDataFrame object, where rows are cells, and columns are cell attributes (such as cell type, culture condition, day captured, etc.) featureData, an AnnotatedDataFrame object, where rows are features (e.g. genes), and columns are feature attributes, such as biotype, gc content, etc. For more details about other features inherited from Bioconductor’s ExpressionSet class, type ?ExpressionSet at the R prompt. When the data are encapsulated in the SCESet class, scater will automatically calculate several different properties. This will be demonstrated in the subsequent chapters. "],
["expression-qc-umi.html", "6 Expression QC (UMI) 6.1 Introduction 6.2 Blischak dataset 6.3 Cell QC 6.4 Cell filtering 6.5 Compare filterings 6.6 Gene analysis 6.7 Save the data 6.8 Big Exercise", " 6 Expression QC (UMI) 6.1 Introduction Once gene expression has been quantified it is summarized as an expression matrix where each row corresponds to a gene (or transcript) and each column corresponds to a single cell. This matrix should be examined to remove poor quality cells which were not detected in either read QC or mapping QC steps. Failure to remove low quality cells at this stage may add technical noise which has the potential to obscure the biological signals of interest in the downstream analysis. Since there is currently no standard method for performing scRNASeq the expected values for the various QC measures that will be presented here can vary substantially from experiment to experiment. Thus, to perform QC we will be looking for cells which are outliers with respect to the rest of the dataset rather than comparing to independent quality standards. Consequently, care should be taken when comparing quality metrics across datasets collected using different protocols. 6.2 Blischak dataset To illustrate cell QC, we consider a dataset of induced pluripotent stem cells generated from three different individuals by John Blischak in Yoav Gilad’s lab at the University of Chicago. The experiments were carried out on the Fluidigm C1 platform and to facilitate the quantification both unique molecular identifiers (UMIs) and ERCC spike-ins were used. The data files are located in the blischak folder in your working directory. These files are the copies of the original files made on the 15/03/16. We will use these copies for reproducibility purposes. library(scater, quietly = TRUE) options(stringsAsFactors = FALSE) Load the data and annotations: molecules &lt;- read.table(&quot;blischak/molecules.txt&quot;, sep = &quot;\\t&quot;) anno &lt;- read.table(&quot;blischak/annotation.txt&quot;, sep = &quot;\\t&quot;, header = TRUE) Inspect a small portion of the expression matrix Table 6.1: A table of the first 6 rows and 3 columns of the molecules table. NA19098.r1.A01 NA19098.r1.A02 NA19098.r1.A03 ENSG00000237683 0 0 0 ENSG00000187634 0 0 0 ENSG00000188976 3 6 1 ENSG00000187961 0 0 0 ENSG00000187583 0 0 0 ENSG00000187642 0 0 0 Table 6.2: A table of the first 6 rows of the anno table. individual replicate well batch sample_id NA19098 r1 A01 NA19098.r1 NA19098.r1.A01 NA19098 r1 A02 NA19098.r1 NA19098.r1.A02 NA19098 r1 A03 NA19098.r1 NA19098.r1.A03 NA19098 r1 A04 NA19098.r1 NA19098.r1.A04 NA19098 r1 A05 NA19098.r1 NA19098.r1.A05 NA19098 r1 A06 NA19098.r1 NA19098.r1.A06 The data consists of 3 individuals and 3 replicates and therefore has 9 batches in total. We standardize the analysis by using the scater package. First, create the scater SCESet classes: pheno_data &lt;- new(&quot;AnnotatedDataFrame&quot;, anno) rownames(pheno_data) &lt;- pheno_data$sample_id umi &lt;- scater::newSCESet( countData = molecules, phenoData = pheno_data ) Remove genes that are not expressed in any cell: keep_feature &lt;- rowSums(is_exprs(umi)) &gt; 0 umi &lt;- umi[keep_feature, ] Define control features (genes) - ERCC spike-ins and mitochondrial genes (provided by the authors): ercc &lt;- featureNames(umi)[grepl(&quot;ERCC-&quot;, featureNames(umi))] mt &lt;- c(&quot;ENSG00000198899&quot;, &quot;ENSG00000198727&quot;, &quot;ENSG00000198888&quot;, &quot;ENSG00000198886&quot;, &quot;ENSG00000212907&quot;, &quot;ENSG00000198786&quot;, &quot;ENSG00000198695&quot;, &quot;ENSG00000198712&quot;, &quot;ENSG00000198804&quot;, &quot;ENSG00000198763&quot;, &quot;ENSG00000228253&quot;, &quot;ENSG00000198938&quot;, &quot;ENSG00000198840&quot;) Calculate the quality metrics: umi &lt;- scater::calculateQCMetrics( umi, feature_controls = list(ERCC = ercc, MT = mt) ) 6.3 Cell QC 6.3.1 Library size Next we consider the total number of RNA molecules detected per sample (if we were using read counts rather than UMI counts this would be the total number of reads). Wells with few reads/molecules are likely to have been broken or failed to capture a cell, and should thus be removed. hist( umi$total_counts, breaks = 100 ) abline(v = 25000, col = &quot;red&quot;) Figure 6.1: Histogram of library sizes for all cells Exercise 1 How many cells does our filter remove? What distribution do you expect that the total number of molecules for each cell should follow? Our answer Table 6.3: The number of cells removed by total counts filter (FALSE) filter_by_total_counts Freq FALSE 46 TRUE 818 If your answer is different please compare your code with ours (you need to search for this exercise in the opened file). 6.3.2 Detected genes (1) In addition to ensuring sufficient sequencing depth for each sample, we also want to make sure that the reads are distributed across the transcriptome. Thus, we count the total number of unique genes detected in each sample. hist( umi$total_features, breaks = 100 ) abline(v = 7000, col = &quot;red&quot;) Figure 6.2: Histogram of the number of detected genes in all cells From the plot we conclude that most cells have between 7,000-10,000 detected genes, which is normal for high-depth scRNA-seq. However, this varies by experimental protocol and sequencing depth. For example, droplet-based methods or samples with lower sequencing-depth typically detect fewer genes per cell. The most notable feature in the above plot is the “heavy tail” on the left hand side of the distribution. If detection rates were equal across the cells then the distribution should be approximately normal. Thus we remove those cells in the tail of the distribution (fewer than 7,000 detected genes). Exercise 2 How many cells does our filter remove? Our answer Table 6.4: The number of cells removed by total features filter (FALSE) filter_by_expr_features Freq FALSE 120 TRUE 744 If your answer is different please compare your code with ours (you need to search for this exercise in the opened file). 6.3.3 ERCCs and MTs Another measure of cell quality is the ratio between ERCC spike-in RNAs and endogenous RNAs. This ratio can be used to estimate the total amount of RNA in the captured cells. Cells with a high level of spike-in RNAs had low starting amounts of RNA, likely due to the cell being dead or stressed which may result in the RNA being degraded. scater::plotPhenoData( umi, aes_string(x = &quot;total_features&quot;, y = &quot;pct_counts_feature_controls_MT&quot;, colour = &quot;batch&quot;) ) Figure 6.3: Percentage of counts in MT genes scater::plotPhenoData( umi, aes_string(x = &quot;total_features&quot;, y = &quot;pct_counts_feature_controls_ERCC&quot;, colour = &quot;batch&quot;) ) Figure 6.4: Percentage of counts in ERCCs The above analysis shows that majority of the cells from NA19098.r2 batch have a very high ERCC/Endo ratio. Indeed, it has been shown by the authors that this batch contains cells of smaller size. Exercise 3 Create filters for removing batch NA19098.r2 and cells with high expression of mitochondrial genes (&gt;10% of total counts in a cell). Our answer Table 6.5: The number of cells removed by ERCC filter (FALSE) filter_by_ERCC Freq FALSE 96 TRUE 768 Table 6.6: The number of cells removed by MT filter (FALSE) filter_by_MT Freq FALSE 31 TRUE 833 If your answer is different please compare your code with ours (you need to search for this exercise in the opened file). Exercise 4 What would you expect to see in the ERCC vs counts plot if you were examining a dataset containing cells of different sizes (eg. normal &amp; senescent cells)? Answer You would expect to see a group corresponding to the smaller cells (normal) with a higher fraction of ERCC reads than a separate group corresponding to the larger cells (senescent). 6.4 Cell filtering 6.4.1 Default Thresholds Results from the biological analysis of single-cell RNA-seq data are often strongly influenced by outliers. Thus, it is important to include multiple filters. A robust way of detecting outliers is through the median absolute difference which is defined as \\(d_i = |r_i - m|\\), where \\(r_i\\) is the number of reads in cell \\(i\\) and \\(m\\) is the median number of reads across the all cells in the sample. By default, scater removes all cells where \\(d_i&gt;5*\\)median(\\(d_i\\)). A similar filter is used for the number of detected genes. Furthermore, scater removes all cells where &gt;80% of counts were assigned to control genes and any cells that have been marked as controls. umi$use_default &lt;- ( # remove cells with unusual numbers of genes !umi$filter_on_total_features &amp; # remove cells with unusual numbers molecules counted !umi$filter_on_total_counts &amp; # &lt; 80% ERCC spike-in !umi$filter_on_pct_counts_feature_controls_ERCC &amp; # &lt; 80% mitochondrial !umi$filter_on_pct_counts_feature_controls_MT &amp; # controls shouldn&#39;t be used in downstream analysis !umi$is_cell_control ) Table 6.7: The number of cells removed by default filter (FALSE) Var1 Freq FALSE 6 TRUE 858 6.4.2 Automatic Another option available in scater is to conduct PCA on a set of QC metrics and then use automatic outlier detection to identify potentially problematic cells. By default, the following metrics are used for PCA-based outlier detection: pct_counts_top_100_features total_features pct_counts_feature_controls n_detected_feature_controls log10_counts_endogenous_features log10_counts_feature_controls scater first creates a matrix where the rows represent cells and the columns represent the different QC metrics. Here, the PCA plot provides a 2D representation of cells ordered by their quality metrics. The outliers are then detected using methods from the mvoutlier package. umi &lt;- scater::plotPCA(umi, size_by = &quot;total_features&quot;, shape_by = &quot;filter_on_total_features&quot;, pca_data_input = &quot;pdata&quot;, detect_outliers = TRUE, return_SCESet = TRUE) ## The following cells/samples are detected as outliers: ## NA19098.r2.A01 ## NA19098.r2.A02 ## NA19098.r2.A06 ## NA19098.r2.A09 ## NA19098.r2.A10 ## NA19098.r2.A12 ## NA19098.r2.B01 ## NA19098.r2.B03 ## NA19098.r2.B04 ## NA19098.r2.B05 ## NA19098.r2.B07 ## NA19098.r2.B11 ## NA19098.r2.B12 ## NA19098.r2.C01 ## NA19098.r2.C02 ## NA19098.r2.C03 ## NA19098.r2.C04 ## NA19098.r2.C05 ## NA19098.r2.C06 ## NA19098.r2.C07 ## NA19098.r2.C08 ## NA19098.r2.C09 ## NA19098.r2.C10 ## NA19098.r2.C11 ## NA19098.r2.C12 ## NA19098.r2.D01 ## NA19098.r2.D02 ## NA19098.r2.D03 ## NA19098.r2.D04 ## NA19098.r2.D07 ## NA19098.r2.D08 ## NA19098.r2.D09 ## NA19098.r2.D10 ## NA19098.r2.D12 ## NA19098.r2.E01 ## NA19098.r2.E02 ## NA19098.r2.E03 ## NA19098.r2.E04 ## NA19098.r2.E05 ## NA19098.r2.E06 ## NA19098.r2.E07 ## NA19098.r2.E12 ## NA19098.r2.F01 ## NA19098.r2.F02 ## NA19098.r2.F07 ## NA19098.r2.F08 ## NA19098.r2.F09 ## NA19098.r2.F10 ## NA19098.r2.F11 ## NA19098.r2.F12 ## NA19098.r2.G01 ## NA19098.r2.G02 ## NA19098.r2.G03 ## NA19098.r2.G05 ## NA19098.r2.G06 ## NA19098.r2.G08 ## NA19098.r2.G09 ## NA19098.r2.G10 ## NA19098.r2.G11 ## NA19098.r2.H01 ## NA19098.r2.H02 ## NA19098.r2.H03 ## NA19098.r2.H04 ## NA19098.r2.H05 ## NA19098.r2.H06 ## NA19098.r2.H07 ## NA19098.r2.H08 ## NA19098.r2.H10 ## NA19098.r2.H12 ## NA19101.r3.A02 ## NA19101.r3.C12 ## NA19101.r3.D01 ## NA19101.r3.E08 ## Variables with highest loadings for PC1 and PC2: ## ## PC1 PC2 ## --------------------------------- ----------- ---------- ## pct_counts_top_100_features 0.4771343 0.3009332 ## pct_counts_feature_controls 0.4735839 0.3309562 ## n_detected_feature_controls 0.1332811 0.5367629 ## log10_counts_feature_controls -0.1427373 0.5911762 ## total_features -0.5016681 0.2936705 ## log10_counts_endogenous_features -0.5081855 0.2757918 Figure 6.5: PCA plot used for automatic detection of cell outliers Table 6.8: The number of cells removed by automatic filter (FALSE) Var1 Freq FALSE 791 TRUE 73 6.4.3 Manual Another option in scater is to use your own filters. We define filters based on our previous analysis: umi$use &lt;- ( # sufficient features (genes) filter_by_expr_features &amp; # sufficient molecules counted filter_by_total_counts &amp; # sufficient endogenous RNA filter_by_ERCC &amp; # remove cells with unusual number of reads in MT genes filter_by_MT ) Table 6.9: The number of cells removed by manual filter (FALSE) Var1 Freq FALSE 210 TRUE 654 6.5 Compare filterings Exercise 5 Compare the default, automatic and manual cell filters. Plot a Venn diagram of the outlier cells from these filterings. Hint: Use limma::vennCounts and limma::vennDiagram functions from the limma package to make a Venn diagram. Answer Figure 6.6: Comparison of the default, automatic and manual cell filters If your answer is different please compare your code with ours (you need to search for this exercise in the opened file). 6.6 Gene analysis 6.6.1 Gene expression In addition to removing cells with poor quality, it is usually a good idea to exclude genes where we suspect that technical artefacts may have skewed the results. Moreover, inspection of the gene expression profiles may provide insights about how the experimental procedures could be improved. It is often instructive to consider the number of reads consumed by the top 50 expressed genes. scater::plotQC(umi, type = &quot;highest-expression&quot;) Figure 6.7: Number of total counts consumed by the top 50 expressed genes The distribution relatively flat indicating (but not guaraneeing!) good coverage of the full transcriptome of these cells. However, there are several spike-ins in the top 15 genes which suggests a greater dilution of the spike-ins may be preferrable if the experiment is to be repeated. 6.6.2 Gene filtering It is typically a good idea to remove genes whose expression level is considered “undetectable”. We define a gene as detectable if at least two cells contain more than 1 transcript from the gene. If we were considering read counts rather than UMI counts a reasonable threshold is to require at least five reads in at least two cells. However, in both cases the threshold strongly depends on the sequencing depth. It is important to keep in mind that genes must be filtered after cell filtering since some genes may only be detected in poor quality cells (note pData(umi)$use filter applied to the umi dataset). filter_genes &lt;- apply(counts(umi[ , pData(umi)$use]), 1, function(x) length(x[x &gt; 1]) &gt;= 2) fData(umi)$use &lt;- filter_genes Table 6.10: The number of genes removed by gene filter (FALSE) filter_genes Freq FALSE 4663 TRUE 14063 Depending on the cell-type, protocol and sequencing depth, other cut-offs may be appropriate. 6.7 Save the data Dimensions of the QCed dataset (do not forget about the gene filter we defined above): dim(umi[fData(umi)$use, pData(umi)$use]) ## Features Samples ## 14063 654 Save the data: saveRDS(umi, file = &quot;blischak/umi.rds&quot;) If you want to further check yourself you can download our umi object. If you followed the steps above it should be exactly the same as yours. 6.8 Big Exercise Perform exactly the same QC analysis with read counts of the same Blischak data. Use blischak/reads.txt file to load the reads. Once you have finished please compare your results to ours (next chapter). "],
["expression-qc-reads.html", "7 Expression QC (Reads)", " 7 Expression QC (Reads) This chapter contains the summary plots and tables for the QC exercise based on the reads for the Bischak data discussed in the previous chapter. Table 7.1: A table of the first 6 rows and 3 columns of the molecules table. NA19098.r1.A01 NA19098.r1.A02 NA19098.r1.A03 ENSG00000237683 0 0 0 ENSG00000187634 0 0 0 ENSG00000188976 57 140 1 ENSG00000187961 0 0 0 ENSG00000187583 0 0 0 ENSG00000187642 0 0 0 Table 7.2: A table of the first 6 rows of the anno table. individual replicate well batch sample_id NA19098 r1 A01 NA19098.r1 NA19098.r1.A01 NA19098 r1 A02 NA19098.r1 NA19098.r1.A02 NA19098 r1 A03 NA19098.r1 NA19098.r1.A03 NA19098 r1 A04 NA19098.r1 NA19098.r1.A04 NA19098 r1 A05 NA19098.r1 NA19098.r1.A05 NA19098 r1 A06 NA19098.r1 NA19098.r1.A06 Figure 7.1: Histogram of library sizes for all cells Table 7.3: The number of cells removed by total counts filter (FALSE) filter_by_total_counts Freq FALSE 180 TRUE 684 Figure 7.2: Histogram of the number of detected genes in all cells Table 7.4: The number of cells removed by total features filter (FALSE) filter_by_expr_features Freq FALSE 120 TRUE 744 Figure 7.3: Library size vs number of detected genes Figure 7.4: Percentage of counts in MT genes Figure 7.5: Percentage of counts in ERCCs Table 7.5: The number of cells removed by ERCC filter (FALSE) filter_by_ERCC Freq FALSE 103 TRUE 761 Table 7.6: The number of cells removed by MT filter (FALSE) filter_by_MT Freq FALSE 18 TRUE 846 Table 7.7: The number of cells removed by default filter (FALSE) Var1 Freq FALSE 37 TRUE 827 ## The following cells/samples are detected as outliers: ## NA19098.r1.B10 ## NA19098.r1.D07 ## NA19098.r1.E04 ## NA19098.r1.F06 ## NA19098.r1.H08 ## NA19098.r1.H09 ## NA19098.r2.A01 ## NA19098.r2.A06 ## NA19098.r2.A09 ## NA19098.r2.A12 ## NA19098.r2.B01 ## NA19098.r2.B11 ## NA19098.r2.B12 ## NA19098.r2.C04 ## NA19098.r2.C09 ## NA19098.r2.D02 ## NA19098.r2.D03 ## NA19098.r2.D09 ## NA19098.r2.E04 ## NA19098.r2.E07 ## NA19098.r2.F01 ## NA19098.r2.F11 ## NA19098.r2.G01 ## NA19098.r2.G05 ## NA19098.r2.G10 ## NA19098.r2.H01 ## NA19098.r2.H07 ## NA19098.r2.H08 ## NA19098.r2.H12 ## NA19098.r3.A05 ## NA19098.r3.A07 ## NA19098.r3.B02 ## NA19098.r3.C07 ## NA19098.r3.E05 ## NA19098.r3.E08 ## NA19098.r3.E09 ## NA19098.r3.F11 ## NA19098.r3.F12 ## NA19098.r3.G02 ## NA19098.r3.G03 ## NA19098.r3.G04 ## NA19098.r3.G11 ## NA19098.r3.G12 ## NA19098.r3.H08 ## NA19101.r1.A01 ## NA19101.r1.A12 ## NA19101.r1.B01 ## NA19101.r1.B06 ## NA19101.r1.E09 ## NA19101.r1.E11 ## NA19101.r1.F05 ## NA19101.r1.F10 ## NA19101.r1.G01 ## NA19101.r1.G06 ## NA19101.r1.H04 ## NA19101.r1.H09 ## NA19101.r2.A03 ## NA19101.r2.C10 ## NA19101.r2.E05 ## NA19101.r2.F02 ## NA19101.r2.H04 ## NA19101.r2.H10 ## NA19101.r3.A02 ## NA19101.r3.A03 ## NA19101.r3.A05 ## NA19101.r3.A09 ## NA19101.r3.B05 ## NA19101.r3.C01 ## NA19101.r3.C09 ## NA19101.r3.C12 ## NA19101.r3.D01 ## NA19101.r3.D04 ## NA19101.r3.D07 ## NA19101.r3.D09 ## NA19101.r3.E08 ## NA19101.r3.F09 ## NA19101.r3.G09 ## NA19101.r3.H01 ## NA19101.r3.H03 ## NA19101.r3.H07 ## NA19101.r3.H09 ## NA19239.r1.F05 ## NA19239.r1.G05 ## NA19239.r2.B01 ## NA19239.r2.B03 ## NA19239.r2.B10 ## NA19239.r2.B11 ## NA19239.r2.C03 ## NA19239.r2.C06 ## NA19239.r2.C08 ## NA19239.r2.D07 ## NA19239.r2.D09 ## NA19239.r2.E09 ## NA19239.r2.F04 ## NA19239.r2.F06 ## NA19239.r2.F07 ## NA19239.r2.F12 ## NA19239.r2.G03 ## NA19239.r2.G08 ## NA19239.r2.H02 ## NA19239.r2.H03 ## NA19239.r2.H07 ## NA19239.r3.A01 ## NA19239.r3.B09 ## NA19239.r3.C04 ## NA19239.r3.C07 ## NA19239.r3.E01 ## NA19239.r3.E03 ## NA19239.r3.E12 ## NA19239.r3.H02 ## NA19239.r3.H10 ## Variables with highest loadings for PC1 and PC2: ## ## PC1 PC2 ## --------------------------------- ----------- ---------- ## pct_counts_feature_controls 0.5057646 0.2473134 ## pct_counts_top_100_features 0.4888852 0.2277068 ## n_detected_feature_controls 0.0231277 0.6235516 ## log10_counts_feature_controls -0.1226860 0.6576822 ## total_features -0.4655518 0.2219694 ## log10_counts_endogenous_features -0.5223679 0.1278782 Figure 7.6: PCA plot used for automatic detection of cell outliers Table 7.8: The number of cells removed by automatic filter (FALSE) Var1 Freq FALSE 753 TRUE 111 Table 7.9: The number of cells removed by manual filter (FALSE) Var1 Freq FALSE 259 TRUE 605 Figure 7.7: Comparison of the default, automatic and manual cell filters Figure 7.8: Number of total counts consumed by the top 50 expressed genes Table 7.10: The number of genes removed by gene filter (FALSE) filter_genes Freq FALSE 2665 TRUE 16061 ## Features Samples ## 16061 605 If you want to further check yourself you can download our reads object. If you followed the steps above it should be exactly the same as yours. By comparing Figure 7.7 and Figure 6.6, it is clear that the reads based filtering removed 49 more cells than the UMI based analysis. If you go back and compare the results you should be able to conclude that the ERCC and MT filters are more strict for the reads-based analysis. "],
["data-visualization.html", "8 Data visualization 8.1 Introduction 8.2 PCA plot 8.3 tSNE map 8.4 Big Exercise", " 8 Data visualization 8.1 Introduction In this chapter we will continue to work with the filtered blischak dataset produced in the previous chapter. We will explore different ways of visualizing the data to allow you to asses what happened to the expression matrix after the quality control step. scater package provides several very useful functions to simplify visualisation. One important aspect of single-cell RNA-seq is to control for batch effects. Batch effects are technical artefacts that are added to the samples during handling. For example, if two sets of samples were prepared in different labs or even on different days in the same lab, then we may observe greater similarities between the samples that were handled together. In the worst case scenario, batch effects may be mistaken for true biological variation. The Blischak data allows us to explore these issues in a controlled manner since some of the salient aspects of how the samples were handled have been recorded. Ideally, we expect to see batches from the same individual grouping together and distinct groups corresponding to each individual. library(scater, quietly = TRUE) options(stringsAsFactors = FALSE) umi &lt;- readRDS(&quot;blischak/umi.rds&quot;) umi.qc &lt;- umi[fData(umi)$use, pData(umi)$use] endog_genes &lt;- !fData(umi.qc)$is_feature_control 8.2 PCA plot The easiest thing to overview the data is to transform it using the principal component analysis and then visualize the first two principal components. Principal component analysis (PCA) is a statistical procedure that uses a transformation to convert a set of observations into a set of values of linearly uncorrelated variables called principal components (PCs). The number of principal components is less than or equal to the number of original variables. PCA is defined in such a way that the first principal component accounts for as much of the variability in the data as possible, and each succeeding component in turn has the highest variance possible under the constraint that it is orthogonal to the preceding components. Figure 8.1: Schematic representation of PCA dimensionality reduction (taken from here) 8.2.1 Before QC scater::plotPCA(umi[endog_genes, ], ntop = 500, colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;counts&quot;) Figure 8.2: PCA plot of the blischak data 8.2.2 After QC scater::plotPCA(umi.qc[endog_genes, ], ntop = 500, colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;counts&quot;) Figure 8.3: PCA plot of the blischak data Comparing Figure 8.2 and Figure 8.3, it is clear that after quality control the NA19098.r2 cells no longer form a group of outliers. By default only the top 500 most variable genes are used by scater to calculate the PCA. This can be adjusted by changing the ntop argument. Exercise 1 How do the PCA plots change if when all 14,214 genes are used? Or when only top 50 genes are used? Our answer Figure 8.4: PCA plot of the blischak data (14214 genes) Figure 8.5: PCA plot of the blischak data (50 genes) If your answers are different please compare your code with ours (you need to search for this exercise in the opened file). 8.3 tSNE map An alternative to PCA for visualizing scRNASeq data is a tSNE plot. tSNE (t-Distributed Stochastic Neighbor Embedding) combines dimensionality reduction (e.g. PCA) with random walks on the nearest-neighbour network to map high dimensional data (i.e. our 14,214 dimensional expression matrix) to a 2-dimensional space while preserving local distances between cells. In contrast with PCA, tSNE is a stochastic algorithm which means running the method multiple times on the same dataset will result in different plots. In the code below we fix the “seed” of the random-number generator so that we always get the same plot. 8.3.1 Before QC scater::plotTSNE(umi[endog_genes, ], ntop = 500, perplexity = 130, colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;counts&quot;, rand_seed = 123456) Figure 8.6: tSNE map of the blischak data 8.3.2 After QC scater::plotTSNE(umi.qc[endog_genes, ], ntop = 500, perplexity = 130, colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;counts&quot;, rand_seed = 123456) Figure 8.7: tSNE map of the blischak data Interpreting PCA and tSNE plots is often challenging. However, in this case it is clear that they provide a similar picture of the data. Comparing Figure 8.6 and 8.7, it is again clear that the samples from NA19098.r2 are no longer outliers after the QC filtering. Furthermore tSNE requires you to provide a value of “perplexity” which reflects the number of neighbours used to build the nearest-neighbour network; a high value creates a dense network which clumps cells together while a low value makes the network more sparse allowing groups of cells to separate from each other. scater uses a default perplexity of the total number of cells divided by five (rounded down). Exercise 2 How do the tSNE plots change when a perplexity of 10 or 200 is used? Our answer Figure 8.8: tSNE map of the blischak data (perplexity = 10) Figure 8.9: tSNE map of the blischak data (perplexity = 200) If your answers are different please compare your code with ours (you need to search for this exercise in the opened file). 8.4 Big Exercise Perform the same analysis with read counts of the Blischak data. Use blischak/reads.rds file to load the reads SCESet object. Once you have finished please compare your results to ours (next chapter). "],
["expression-overview-reads.html", "9 Expression overview (Reads)", " 9 Expression overview (Reads) Figure 9.1: PCA plot of the blischak data Figure 9.2: PCA plot of the blischak data Figure 9.3: tSNE map of the blischak data Figure 9.4: tSNE map of the blischak data Figure 9.5: tSNE map of the blischak data (perplexity = 10) Figure 9.6: tSNE map of the blischak data (perplexity = 200) "],
["confounding-factors.html", "10 Confounding factors 10.1 Introduction 10.2 Correlations with PCs 10.3 Explanatory variables 10.4 Other confounders 10.5 Exercise", " 10 Confounding factors 10.1 Introduction There is a large number of potential confounders, artifacts and biases in sc-RNA-seq data. One of the main challenges in analyzing scRNA-seq data stems from the fact that it is difficult to carry out a true technical replicate (why?) to distinguish biological and technical variability. In the previous chapters we considered batch effects and in this chapter we will continue to explore how experimental artifacts can be identified and removed. We will continue using the scater package since it provides a set of methods specifically for quality control of experimental and explanatory variables. Moreover, we will continue to work with the Blischak data that was used in the previous chapter. library(scater, quietly = TRUE) options(stringsAsFactors = FALSE) umi &lt;- readRDS(&quot;blischak/umi.rds&quot;) umi.qc &lt;- umi[fData(umi)$use, pData(umi)$use] endog_genes &lt;- !fData(umi.qc)$is_feature_control The umi.qc dataset contains filtered cells and genes. Our next step is to explore technical drivers of variability in the data to inform data normalisation before downstream analysis. 10.2 Correlations with PCs Let’s first look again at the PCA plot of the QCed dataset: scater::plotPCA(umi.qc[endog_genes, ], colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, exprs_values = &quot;counts&quot;) Figure 10.1: PCA plot of the blischak data scater allows one to identify principle components that correlate with experimental and QC variables of interest (it ranks principle components by \\(R^2\\) from a linear model regressing PC value against the variable of interest). Let’s test whether some of the variables correlate with any of the PCs. 10.2.1 Detected genes scater::plotQC(umi.qc[endog_genes, ], type = &quot;find-pcs&quot;, variable = &quot;total_features&quot;, exprs_values = &quot;counts&quot;) Figure 10.2: PC correlation with the number of detected genes Indeed, we can see that PC1 can be completely explained by the number of the detected genes. In fact, it was also visible on the PCA plot above. This is a well-known issue in scRNA-seq and was described here. 10.3 Explanatory variables scater can also compute the marginal \\(R^2\\) for each variable when fitting a linear model regressing expression values for each gene against just that variable, and display a density plot of the gene-wise marginal \\(R^2\\) values for the variables. scater::plotQC(umi.qc[endog_genes, ], type = &quot;expl&quot;, exprs_values = &quot;counts&quot;, variables = c(&quot;total_features&quot;, &quot;total_counts&quot;, &quot;batch&quot;, &quot;individual&quot;, &quot;pct_counts_feature_controls_ERCC&quot;, &quot;pct_counts_feature_controls_MT&quot;)) Figure 10.3: Explanatory variables This analysis indicates that the number of detected genes (again) and also the sequencing depth (number of counts) have substantial explanatory power for many genes, so these variables are good candidates for conditioning out in a normalisation step, or including in downstream statistical models. Expression of ERCCs also appears to be an important explanatory variable. 10.4 Other confounders In addition to correcting for batch, there are other factors that one may want to compensate for. As with batch correction, these adjustments require extrinsic information. One popular method is scLVM which allows you to identify and subtract the effect from processes such as cell-cycle or apoptosis. In addition, protocols may differ in terms of their coverage of each transcript, their bias based on the average content of A/T nucleotides, or their ability to capture short transcripts. Ideally, we would like to compensate for all of these differences and biases. 10.5 Exercise Perform the same analysis with read counts of the Blischak data. Use blischak/reads.rds file to load the reads SCESet object. Once you have finished please compare your results to ours (next chapter). "],
["confounding-factors-reads.html", "11 Confounding factors (Reads)", " 11 Confounding factors (Reads) Figure 11.1: PCA plot of the blischak data Figure 11.2: PC correlation with the number of detected genes Figure 11.3: Explanatory variables "],
["normalization-for-library-size.html", "12 Normalization for library size 12.1 Introduction 12.2 Library size 12.3 Normalisations 12.4 Downsampling 12.5 Normalizing for gene/transcript length 12.6 Exercise", " 12 Normalization for library size 12.1 Introduction In the previous chapter we identified important confounding factors and explanatory variables. scater allows one to account for these variables in subsequent statistical models or to condition them out using normaliseExprs(), if so desired. This can be done by providing a design matrix to normaliseExprs(). We are not covering this topic here, but you can try to do it yourself as an exercise. Instead we will explore how simple size-factor normalisations correcting for library size can remove the effects of some of the confounders and explanatory variables. 12.2 Library size Library sizes vary because scRNA-seq data is often sequenced on highly multiplexed platforms the total reads which are derived from each cell may differ substantially. Some quantification methods (eg. Cufflinks, RSEM) incorporated library size when determining gene expression estimates thus do not require this normalization. However, if another quantification method was used then library size must be corrected for by multiplying or dividing each column of the expression matrix by a “normalization factor” which is an estimate of the library size relative to the other cells. Many methods to correct for library size have been developped for bulk RNA-seq and can be equally applied to scRNA-seq (eg. UQ, SF, CPM, RPKM, FPKM, TPM). 12.3 Normalisations The simplest way to normalize this data is to convert it to counts per million (CPM) by dividing each column by its total then multiplying by 1,000,000. Note that spike-ins should be excluded from the calculation of total expression in order to correct for total cell RNA content, therefore we will only use endogenous genes. calc_cpm &lt;- function (expr_mat, spikes = NULL) { norm_factor &lt;- colSums(expr_mat[-spikes, ]) return(t(t(expr_mat)/norm_factor)) * 10^6 } One potential drawback of CPM is if your sample contains genes that are both very highly expressed and differentially expressed across the cells. In this case, the total molecules in the cell may depend of whether such genes are on/off in the cell and normalizing by total molecules may hide the differential expression of those genes and/or falsely create differential expression for the remaining genes. Note: RPKM, FPKM and TPM are variants on CPM which further adjust counts by the length of the respective gene/transcript. To deal with this potentiality several other measures were devised: The size factor (SF) was proposed and popularized by DESeq (Anders and Huber (2010)). First the geometric mean of each gene across all cells is calculated. The size factor for each cell is the median across genes of the ratio of the expression to the gene’s geometric mean. A draw back to this method is that since it uses the geometric mean only genes with non-zero expression values across all cells can be used in its calculation, making it unadvisable for large low-depth scRNASeq experiments. edgeR &amp; scater call this method RLE for “relative log expression”. calc_sf &lt;- function (expr_mat, spikes = NULL) { geomeans &lt;- exp(rowMeans(log(expr_mat[-spikes, ]))) SF &lt;- function(cnts) { median((cnts/geomeans)[(is.finite(geomeans) &amp; geomeans &gt; 0)]) } norm_factor &lt;- apply(expr_mat[-spikes, ], 2, SF) return(t(t(expr_mat)/norm_factor)) } The upperquartile (UQ) was proposed by Bullard et al (2010). Here each column is divided by the 75% quantile of the counts for each library. Often the calculated quantile is scaled by the median across cells to keep the absolute level of expression relatively consistent. A draw back to this method is that for low-depth scRNASeq experiments the large number of undetected genes may result in the 75% quantile being zero (or close to it). This limitation can be overcome by generalizing the idea and using a higher quantile (eg. the 99% quantile is the default in scater) or by excluding zeros prior to calculating the 75% quantile. calc_uq &lt;- function (expr_mat, spikes = NULL) { UQ &lt;- function(x) { quantile(x[x &gt; 0], 0.75) } uq &lt;- unlist(apply(expr_mat[-spikes, ], 2, UQ)) norm_factor &lt;- uq/median(uq) return(t(t(expr_mat)/norm_factor)) } Another method is called TMM is the weighted trimmed mean of M-values (to the reference) proposed by Robinson and Oshlack (2010). The M-values in question are the gene-wise log2 fold changes between individual cells. One cell is used as the reference then the M-values for each other cell is calculated compared to this reference. These values are then trimmed by removing the top and bottom ~30%, and the average of the remaining values is calculated by weighting them to account for the effect of the log scale on variance. Each non-reference cell is multiplied by the calculated factor. Two potential issues with this method are insufficient non-zero genes left after trimming, and the assumption that most genes are not differentially expressed. Finally the scran package implements a variant on CPM specialized for single-cell data (Lun et al 2016). Briefly this method deals with the problem of vary large numbers of zero values per cell by pooling cells together calculating a normalization factor (similar to CPM) for the sum of each pool. Since each cell is found in many different pools, cell-specific factors can be deconvoluted from the collection of pool-specific factors using linear algebra. We will use visual inspection of PCA plots and calculation of cell-wise relative log expression (calc_cell_RLE()) to compare the efficiency of different normalization methods. Cells with many[few] reads have higher[lower] than median expression for most genes resulting in a positive[negative] RLE across the cell, whereas normalized cells have an RLE close to zero. calc_cell_RLE &lt;- function (expr_mat, spikes = NULL) { RLE_gene &lt;- function(x) { if (median(unlist(x)) &gt; 0) { log((x + 1)/(median(unlist(x)) + 1))/log(2) } else { rep(NA, times = length(x)) } } if (!is.null(spikes)) { RLE_matrix &lt;- t(apply(expr_mat[-spikes, ], 1, RLE_gene)) } else { RLE_matrix &lt;- t(apply(expr_mat, 1, RLE_gene)) } cell_RLE &lt;- apply(RLE_matrix, 2, median, na.rm = T) return(cell_RLE) } The RLE, TMM, and UQ size-factor methods were developed for bulk RNA-seq data and, depending on the experimental context, may not be appropriate for single-cell RNA-seq data, as their underlying assumptions may be problematically violated. Lun et al (2016) recently published a size-factor normalisation method specifically designed for scRNA-seq data and accounting for single-cell biases, which we will call LSF (Lun Sum Factors). Briefly, expression values are summed across pools of cells and the summed values are used to compute normalization size-factors per pool. The pool-based size factors can then be deconvolved into cell-specific size factors, which can be used for normalization in the same way as other size factors. scater acts as a wrapper for the calcNormFactors function from edgeR which implements several library size normalization methods making it easy to apply any of these methods to our data. The LSF method is implementated in the Bioconductor package scran, which allows seamless integrationinto the scater workflow. (The scran package itself depends on scater). Note: edgeR makes extra adjustments to some of the normalization methods which may result in somewhat different results than if the original methods are followed exactly, e.g. edgeR’s and scater’s “RLE” method which is based on the “size factor” used by DESeq may give different results to the estimateSizeFactorsForMatrix method in the DESeq/DESeq2 packages. In addition, some versions of edgeR will not calculate the normalization factors correctly unless lib.size is set at 1 for all cells. We will continue to work with the Blischak data that was used in the previous chapter. library(scRNA.seq.funcs) library(scater, quietly = TRUE) options(stringsAsFactors = FALSE) umi &lt;- readRDS(&quot;blischak/umi.rds&quot;) umi.qc &lt;- umi[fData(umi)$use, pData(umi)$use] endog_genes &lt;- !fData(umi.qc)$is_feature_control 12.3.1 Raw scater::plotPCA(umi.qc[endog_genes, ], colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;counts&quot;) Figure 12.1: PCA plot of the blischak data boxplot(calc_cell_RLE(counts(umi.qc[endog_genes, ])), col = &quot;grey50&quot;, ylab = &quot;RLE&quot;, main = &quot;&quot;, ylim=c(-1,1)) Figure 12.2: Cell-wise RLE of the blischak data 12.3.2 CPM scater performs this normalisation by default, you can control it by changing exprs_values parameter to &quot;exprs&quot;. scater::plotPCA(umi.qc[endog_genes, ], colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;cpm&quot;) Figure 12.3: PCA plot of the blischak data after CPM normalisation boxplot(calc_cell_RLE(cpm(umi.qc[endog_genes, ])), col = &quot;grey50&quot;, ylab = &quot;RLE&quot;, main = &quot;&quot;, ylim = c(-1,1)) Figure 12.4: Cell-wise RLE of the blischak data 12.3.3 TMM umi.qc &lt;- scater::normaliseExprs(umi.qc, method = &quot;TMM&quot;, feature_set = endog_genes) scater::plotPCA(umi.qc[endog_genes, ], colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;norm_counts&quot;) Figure 12.5: PCA plot of the blischak data after TMM normalisation boxplot(calc_cell_RLE(norm_counts(umi.qc[endog_genes, ])), col = &quot;grey50&quot;, ylab = &quot;RLE&quot;, main = &quot;&quot;, ylim=c(-1,1)) Figure 12.6: Cell-wise RLE of the blischak data 12.3.4 scran qclust &lt;- scran::quickCluster(umi.qc, min.size = 30) umi.qc &lt;- scran::computeSumFactors(umi.qc, sizes = 15, clusters = qclust) umi.qc &lt;- scater::normalize(umi.qc) scater::plotPCA(umi.qc[endog_genes, ], colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;exprs&quot;) Figure 12.7: PCA plot of the blischak data after LSF normalisation boxplot(calc_cell_RLE(exprs(umi.qc[endog_genes, ])), col = &quot;grey50&quot;, ylab = &quot;RLE&quot;, main = &quot;&quot;, ylim=c(-1,1)) Figure 12.8: Cell-wise RLE of the blischak data 12.3.5 Size-factor (RLE) umi.qc &lt;- scater::normaliseExprs(umi.qc, method = &quot;RLE&quot;, feature_set = endog_genes) scater::plotPCA(umi.qc[endog_genes, ], colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;norm_counts&quot;) Figure 12.9: PCA plot of the blischak data after RLE normalisation boxplot(calc_cell_RLE(norm_counts(umi.qc[endog_genes, ])), col = &quot;grey50&quot;, ylab = &quot;RLE&quot;, main = &quot;&quot;, ylim=c(-1,1)) Figure 12.10: Cell-wise RLE of the blischak data 12.3.6 Upperquantile umi.qc &lt;- scater::normaliseExprs(umi.qc, method = &quot;upperquartile&quot;, feature_set = endog_genes, p = 0.99) scater::plotPCA(umi.qc[endog_genes, ], colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;norm_counts&quot;) Figure 12.11: PCA plot of the blischak data after UQ normalisation boxplot(calc_cell_RLE(norm_counts(umi.qc[endog_genes, ])), col = &quot;grey50&quot;, ylab = &quot;RLE&quot;, main = &quot;&quot;, ylim = c(-1, 1)) Figure 12.12: Cell-wise RLE of the blischak data 12.4 Downsampling A final way to correct for library size is to downsample the expression matrix so that each cell has approximately the same total number of molecules. The benefit of this method is that zero values will be introduced by the down sampling thus eliminating any biases due to differing numbers of detected genes. However, the major drawback is that the process is not deterministic so each time the downsampling is run the resulting expression matrix is slightly different. Thus, often analyses must be run on multiple downsamplings to ensure results are robust. Down_Sample_Matrix &lt;- function (expr_mat) { min_lib_size &lt;- min(colSums(expr_mat)) down_sample &lt;- function(x) { prob &lt;- min_lib_size/sum(x) return(unlist(lapply(x, function(y) { rbinom(1, y, prob) }))) } down_sampled_mat &lt;- apply(expr_mat, 2, down_sample) return(down_sampled_mat) } norm_counts(umi.qc) &lt;- scRNA.seq.funcs::Down_Sample_Matrix(counts(umi.qc)) scater::plotPCA(umi.qc[endog_genes, ], colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;norm_counts&quot;) Figure 12.13: PCA plot of the blischak data after downsampling tmp &lt;- norm_counts(umi.qc[endog_genes, ]) # ignore genes which are not detected in any cells following downsampling boxplot(calc_cell_RLE(tmp[rowMeans(tmp) &gt; 0, ]), col = &quot;grey50&quot;, ylab = &quot;RLE&quot;, main = &quot;&quot;, ylim = c(-1, 1)) Figure 12.14: Cell-wise RLE of the blischak data 12.5 Normalizing for gene/transcript length Some methods combine library size and fragment/gene length normalization such as: RPKM - Reads Per Kilobase Million (for single-end sequencing) FPKM - Fragments Per Kilobase Million (same as RPKM but for paired-end sequencing, makes sure that paired ends mapped to the same fragment are not counted twice) TPM - Transcripts Per Kilobase Million (same as RPKM, but the order of normalizations is reversed - length first and sequencing depth second) These methods are not applicable to our dataset since the end of the transcript which contains the UMI was preferentially sequenced. Furthermore in general these should only be calculated using appropriate quantification software from aligned BAM files not from read counts since often only a portion of the entire gene/transcript is sequenced, not the entire length. If in doubt check for a relationship between gene/transcript length and expression level. However, here we show how these normalisations can be calculated using scater. First, we need to find the effective transcript length in Kilobases. However, our dataset containes only gene IDs, therefore we will be using the gene lengths instead of transcripts. scater uses the biomaRt package, which allows one to annotate genes by other attributes: umi.qc &lt;- scater::getBMFeatureAnnos(umi.qc, filters = &quot;ensembl_gene_id&quot;, attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;, &quot;chromosome_name&quot;, &quot;start_position&quot;, &quot;end_position&quot;), feature_symbol = &quot;hgnc_symbol&quot;, feature_id = &quot;ensembl_gene_id&quot;, biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;, host = &quot;www.ensembl.org&quot;) # If you have mouse data, change the arguments based on this example: # scater::getBMFeatureAnnos(object, # filters = &quot;ensembl_transcript_id&quot;, # attributes = c(&quot;ensembl_transcript_id&quot;, # &quot;ensembl_gene_id&quot;, &quot;mgi_symbol&quot;, # &quot;chromosome_name&quot;, # &quot;transcript_biotype&quot;, # &quot;transcript_start&quot;, # &quot;transcript_end&quot;, # &quot;transcript_count&quot;), # feature_symbol = &quot;mgi_symbol&quot;, # feature_id = &quot;ensembl_gene_id&quot;, # biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;, # dataset = &quot;mmusculus_gene_ensembl&quot;, # host = &quot;www.ensembl.org&quot;) Some of the genes were not annotated, therefore we filter them out: umi.qc.ann &lt;- umi.qc[!is.na(fData(umi.qc)$ensembl_gene_id), ] Now we compute the total gene length in Kilobases by using the end_position and start_position fields: eff_length &lt;- abs(fData(umi.qc.ann)$end_position - fData(umi.qc.ann)$start_position)/1000 plot(eff_length, rowMeans(counts(umi.qc.ann))) Figure 12.15: Gene length vs Mean Expression for the raw data There is no relationship between gene length and mean expression so FPKMs &amp; TPMs are inappropriate for this dataset. But we will demonstrate them anyway. Now we are ready to perform the normalisations: tpm(umi.qc.ann) &lt;- calculateTPM( umi.qc.ann, eff_length ) fpkm(umi.qc.ann) &lt;- calculateFPKM( umi.qc.ann, eff_length ) Plot the results as a PCA plot: scater::plotPCA(umi.qc.ann, colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;fpkm&quot;) Figure 12.16: PCA plot of the blischak data after FPKM normalisation scater::plotPCA(umi.qc.ann, colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;tpm&quot;) Figure 12.17: PCA plot of the blischak data after TPM normalisation Note: The PCA looks for differences between cells. Gene length is the same across cells for each gene thus FPKM is almost identical to the CPM plot (it is just rotated) since it performs CPM first then normalizes gene length. Whereas, TPM is different because it weights genes by their length before performing CPM. 12.6 Exercise Perform the same analysis with read counts of the Blischak data. Use blischak/reads.rds file to load the reads SCESet object. Once you have finished please compare your results to ours (next chapter). "],
["normalization-for-library-size-reads.html", "13 Normalization for library size (Reads)", " 13 Normalization for library size (Reads) Figure 13.1: PCA plot of the blischak data Figure 13.2: Cell-wise RLE of the blischak data Figure 13.3: PCA plot of the blischak data after CPM normalisation Figure 13.4: Cell-wise RLE of the blischak data Figure 13.5: PCA plot of the blischak data after TMM normalisation Figure 13.6: Cell-wise RLE of the blischak data Figure 13.7: PCA plot of the blischak data after LSF normalisation Figure 13.8: Cell-wise RLE of the blischak data Figure 13.9: PCA plot of the blischak data after RLE normalisation Figure 13.10: Cell-wise RLE of the blischak data Figure 13.11: PCA plot of the blischak data after UQ normalisation Figure 13.12: Cell-wise RLE of the blischak data Figure 13.13: PCA plot of the blischak data after downsampling Figure 13.14: Cell-wise RLE of the blischak data Figure 13.15: PCA plot of the blischak data after FPKM normalisation Figure 13.16: PCA plot of the blischak data after TPM normalisation "],
["remove-confounders-using-controls.html", "14 Remove confounders using controls 14.1 Introduction 14.2 Remove Unwanted Variation 14.3 Effectiveness 1 14.4 Effectiveness 2 14.5 Exercise", " 14 Remove confounders using controls 14.1 Introduction In the previous chapter we normalized for library size, effectively removing it as a confounder. Now we will consider removing other less well defined confounders from our data using the ERCC spike-in controls. Technical confounders (aka batch effects) can arise from difference in reagents, isolation methods, the lab/experimenter who performed the experiment, even which day/time the experiment was performed. Since the same amount of ERCC spike-in was added to each cell in our experiment we know that all the variablity we observe for these genes is due to technical noise; whereas endogenous genes are affected by both technical noise and biological variability. Technical noise can be removed by fitting a model to the spike-ins and “substracting” this from the endogenous genes. There are several methods available based on this premise (eg. BASiCS, scLVM, RUV); each using different noise models and different fitting procedures. Alternatively, one can identify genes which exhibit significant variation beyond technical noise (eg. Distance to median, Highly variable genes) library(scRNA.seq.funcs) library(RUVSeq) library(scater, quietly = TRUE) library(scran) options(stringsAsFactors = FALSE) umi &lt;- readRDS(&quot;blischak/umi.rds&quot;) umi.qc &lt;- umi[fData(umi)$use, pData(umi)$use] endog_genes &lt;- !fData(umi.qc)$is_feature_control erccs &lt;- fData(umi.qc)$is_feature_control 14.2 Remove Unwanted Variation Factors contributing to technical noise frequently appear as “batch effects” where cells processed on different days or by different technicians systematically vary from one another. Removing technical noise and correcting for batch effects can frequently be performed using the same tool or slight variants on it. We will be considering the Remove Unwanted Variation (RUV) method which uses singular value decomposition (similar to PCA) on subsets of the dataset which should be invariant (e.g. ERCC spike-ins). Then the method removes the identified unwanted factors. qclust &lt;- scran::quickCluster(umi.qc, min.size = 30) umi.qc &lt;- scran::computeSumFactors(umi.qc, sizes = 15, clusters = qclust) umi.qc &lt;- scater::normalize(umi.qc) assayData(umi.qc)$ruv_counts &lt;- RUVSeq::RUVg( round(exprs(umi.qc)), erccs, k = 1)$normalizedCounts 14.3 Effectiveness 1 We evaluate the effectiveness of the normalization by inspecting the PCA plot where shape corresponds the technical replicate and colour corresponds to different biological samples (individuals from whom the iPSC lines where derived). Separation of biological samples and interspersed batches indicates that technical variation has been removed. scater::plotPCA(umi.qc[endog_genes, ], colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;exprs&quot;) Figure 14.1: PCA plot of the blischak data after RLE normalisation scater::plotPCA(umi.qc[endog_genes, ], colour_by = &quot;batch&quot;, size_by = &quot;total_features&quot;, shape_by = &quot;individual&quot;, exprs_values = &quot;ruv_counts&quot;) Figure 14.2: PCA plot of the blischak data after RLE and RUV normalisations 14.4 Effectiveness 2 We can also examine the relative log expression (RLE) across cells to confirm technical noise has been removed from the dataset. boxplot(list(scRNA.seq.funcs::calc_cell_RLE(exprs(umi.qc), erccs), scRNA.seq.funcs::calc_cell_RLE(assayData(umi.qc)$ruv_counts, erccs))) Figure 14.3: Comparison of the relative log expression of the blischak data before and after the RUV normalisation 14.5 Exercise Perform the same analysis with read counts of the Blischak data. Use blischak/reads.rds file to load the reads SCESet object. Once you have finished please compare your results to ours (next chapter). Additionally, experiment with other combinations of normalizations and compare the results. "],
["remove-confounders-using-controls-reads.html", "15 Remove confounders using controls (Reads)", " 15 Remove confounders using controls (Reads) Figure 15.1: PCA plot of the blischak data after RLE normalisation Figure 15.2: PCA plot of the blischak data after RLE and RUV normalisations Figure 15.3: Comparison of the relative log expression of the blischak data before and after the RUV normalisation "],
["clustering-analysis.html", "16 Clustering analysis 16.1 Introduction 16.2 Dimensionality reductions 16.3 Clustering methods 16.4 Challenges in clustering 16.5 Tools for scRNA-seq data", " 16 Clustering analysis Once we have normalized the data and removed confounders we can carry out analyses that will allow us to interpret the data biologically. The exact nature of the analysis depends on the dataset and the biological question at hand. Nevertheless, there are a few operations which are useful in a wide range of contexts and we will be discussing some of them. We will start with the clustering of scRNA-seq data. 16.1 Introduction One of the most promising applications of scRNA-seq is the discovery and annotation of cell-types based on the transcription profiles. Computationally, this is a hard problem as it amounts to unsupervised clustering. That is, we need to identify groups of cells based on the similarities of the transcriptomes without any prior knowledge of the labels. The problem is made more challenging due to the high level of noise and the large number of dimensions (i.e. genes). 16.2 Dimensionality reductions When working with large datasets, it can often be beneficial to apply some sort of dimensionality reduction method. By projecting the data onto a lower-dimensional sub-space, one is often able to significantly reduce the amount of noise. An additional benefit is that it is typically much easier to visualize the data in a 2 or 3-dimensional subspace. Here we will introduce some of the popular dimensionality reduction methods. 16.2.1 PCA PCA analysis was introduced in chapter 8.2. 16.2.2 Spectral Spectral decomposition is the factorization of a matrix into a canonical form, whereby the matrix is represented in terms of its eigenvalues and eigenvectors. In application to scRNA-seq data, the matrix can be either an input expression matrix, or matrix of distances between the cells. The computed eigenvectors are similar to the projections of the data to PCs (chapter 8.2.). 16.2.3 tSNE tSNE analysis was introduced in chapter 8.3. 16.3 Clustering methods Unsupervised clustering is useful in many different applications and it has been widely studied in machine learning. Some of the most popular approaches are discussed below. 16.3.1 Hierarchical clustering In hierarchical clustering, one can use either a bottom-up or a top-down approach. In the former case, each cell is initially assigned to its own cluster and pairs of clusters are subsequently merged to create a hieararchy: Figure 16.1: Raw data Figure 16.2: The hierarchical clustering dendrogram With a top-down strategy, one instead starts with all observations in one cluster and then recursively split each cluster to form a hierarchy. One of the advantages of this strategy is that the method is deterministic. 16.3.2 k-means In k-means clustering, the goal is to partition N cells into k different clusters. In an iterative manner, cluster centers are assigned and each cell is assigned to its nearest cluster: Figure 16.3: Schematic representation of the k-means clustering Most methods for scRNA-seq analysis includes a k-means step at some point. 16.3.3 Graph-based methods Over the last two decades there has been a lot of interest in analyzing networks in various domains. One goal is to identify groups or modules of nodes in a network. Figure 16.4: Schematic representation of the graph network Some of these methods can be applied to scRNA-seq data and one example is the method, which is based on the concept of identifying groups of tightly connected nodes. 16.4 Challenges in clustering What is the number of clusters k? Scalability: in the last 2 years the number of cells in scRNA-seq experiments has grown by 2 orders of magnitude from ~\\(10^2\\) to ~\\(10^4\\) Tools are not user-friendly 16.5 Tools for scRNA-seq data 16.5.1 SINCERA SINCERA (Guo et al. 2015) is based on hierarchical clustering Data is converted to z-scores before clustering Identify k by finding the first singleton cluster in the hierarchy 16.5.2 pcaReduce pcaReduce (Žurauskienė and Yau 2016) combines PCA, k-means and “iterative” hierarchical clustering. Starting from a large number of clusters pcaReduce iteratively merges similar clusters; after each merging event it removes the principle component explaning the least variance in the data. 16.5.3 SC3 Figure 16.5: SC3 pipeline SC3 (Kiselev et al. 2016) is based on PCA and spectral dimensionality reductions Utilises k-means Additionally performs the consensus clustering 16.5.4 tSNE + k-means Based on tSNE maps Utilises k-means 16.5.5 SEURAT SEURAT (Macosko et al. 2015) first ustilises PCA on a set of cells, then a number of statistically significant PCs is defined. Those PCs are further projected to a 2D space using tSNE. The remaining cells are then projected on the same tSNE map. Density clustering algorithm (DBSCAN) is then used to identify cell clusters in the 2D space. 16.5.6 SNN-Cliq SNN-Cliq (C. Xu and Su 2015) is a graph-based method. First the method identifies the k-nearest-neighbours of each cell according to the distance measure. This is used to calculate the number of Shared Nearest Neighbours (SNN) between each pair of cells. A graph is built by placing an edge between two cells If they have at least one SNN. Clusters are defined as groups of cells with many edges between them using a “clique” method. SNN-Cliq requires several parameters to be defined manually. References "],
["clust-methods.html", "17 Clustering example 17.1 Patient dataset 17.2 SC3 17.3 pcaReduce 17.4 tSNE + kmeans 17.5 SNN-Cliq 17.6 SINCERA 17.7 SEURAT", " 17 Clustering example library(scRNA.seq.funcs) library(pcaMethods) library(pcaReduce) library(Rtsne) library(SC3) library(pheatmap) library(ggplot2) set.seed(1234567) To illustrate clustering of scRNA-seq data, we consider a dataset of hematopoietic stem cells (HSCs) collected from a patient with myeloproliferative neoplasm (MPN). It is well known that this disease is highly heterogeneous with multiple sub-clones co-existing within the same patient. 17.1 Patient dataset Traditionally, clonal heterogeneity has been assessed by genotyping sub-clones. Genotyping through Sanger sequencing of two key loci has been carried out for this patient and it has revealed the presence of 3 different sub-clones (WT, WT/Tet2 and Jak2/Tet2). Our goal is to identify clusters corresponding to the three genotypes from the scRNA-seq data. patient.data &lt;- read.table(&quot;clustering/patient.txt&quot;, sep = &quot;\\t&quot;) For convenience we have performed all quality control and normalization steps (SF + RUV) in advance. The dataset contains 51 cells and 8710 genes. Now we are ready to cluster the data using the methods described in the previous chapter. 17.2 SC3 SC3::sc3(patient.data, ks = 2:5) This command will open SC3 in a web browser. Once it is opened please perform the following exercises: Exercise 1: Explore different clustering solutions for \\(k\\) from 2 to 5. Also try to change the consensus averaging by checking and unchecking distance and transformation check boxes in the left panel of SC3. Exercise 2: Based on the genotyping, we strongly believe that \\(k =3\\) provides the best clustering. What evidence do you find for this in the clustering? How can you use the silhouette plots to motivate choosing the value of \\(k\\) that you think looks best? Exercise 3: The solution may change depending on the combination of check-boxes that was used. How similar are the different solutions, and which are the most stable clusterings? You can find out how different cells migrate between clusters using the “Cell Labels” tab panel. Exercise 4: Calculate differentially expressed genes and marker genes for the obtained clusterings. Please use \\(k=3\\) and the most stable solution, corresponding to the case when all check boxes are checked. Exercise 5: Change the marker genes threshold (the default is 0.85) in the right side panel of SC3. Does SC3 find more marker genes? 17.3 pcaReduce # use the same gene filter as in SC3 input &lt;- scRNA.seq.funcs::gene_filter(patient.data, 0.06) # log transform before the analysis input.log &lt;- log2(input + 1) # run pcaReduce 10 times creating hierarchies from 1 to 30 clusters pca.red &lt;- pcaReduce::PCAreduce(t(input.log), nbt = 10, q = 30, method = &#39;S&#39;) res &lt;- unique(scRNA.seq.funcs::merge_pcaReduce_results(pca.red, 3)) pheatmap::pheatmap(res) Figure 17.1: Clustering solutions of pcaReduce method after running it for 10 times and selecting \\(k=3\\) Exercise 6: Run pcaReduce for \\(k=2\\), \\(k=4\\) and \\(k=5\\). Is it easy to choose the optimal \\(k\\)? Hint: When running pcaReduce for different \\(k\\)s you do not need to rerun pcaReduce::PCAreduce function, just use already calculated pca.red object. Our solutions: Figure 17.2: Clustering solutions of pcaReduce method after running it for 10 times and selecting \\(k=2\\). Figure 17.3: Clustering solutions of pcaReduce method after running it for 10 times and selecting \\(k=4\\). Figure 17.4: Clustering solutions of pcaReduce method after running it for 10 times and selecting \\(k=5\\). Exercise 7: Compare the results between SC3 and pcaReduce. What is the main difference between the solutions provided by the two different methods? 17.4 tSNE + kmeans tSNE plots that we saw before (8.3) when used the scater package are made by using the Rtsne and ggplot2 packages. We can create a similar plots explicitly: tsne_out &lt;- Rtsne::Rtsne(t(input.log), perplexity = 10) df_to_plot &lt;- as.data.frame(tsne_out$Y) comps &lt;- colnames(df_to_plot)[1:2] ggplot2::ggplot(df_to_plot, aes_string(x = comps[1], y = comps[2])) + geom_point() + xlab(&quot;Dimension 1&quot;) + ylab(&quot;Dimension 2&quot;) + theme_bw() Figure 17.5: tSNE map of the patient data Note that all points on the plot above are black. This is different from what we saw before, when the cells were coloured based on the annotation. Here we do not have any annotation and all cells come from the same batch, therefore all dots are black. Now we are going to apply k-means clustering algorithm to the cloud of points on the tSNE map. Do you see 2/3/4/5 groups in the cloud? We will start with \\(k=2\\): clusts &lt;- stats::kmeans(tsne_out$Y, centers = 2, iter.max = 1e+09, nstart = 1000)$clust df_to_plot$clusts &lt;- factor(clusts, levels = unique(clusts)) comps &lt;- colnames(df_to_plot)[1:3] ggplot2::ggplot(df_to_plot, aes_string(x = comps[1], y = comps[2], color = comps[3])) + geom_point() + xlab(&quot;Dimension 1&quot;) + ylab(&quot;Dimension 2&quot;) + theme_bw() Figure 17.6: tSNE map of the patient data with 2 colored clusters, identified by the k-means clustering algorithm Exercise 7: Make the same plots for \\(k=3\\), \\(k=4\\) and \\(k=5\\). Exercise 8: Compare the results between SC3 and tSNE+kmeans. Can the results be improved by changing the perplexity parameter? As you may have noticed, both pcaReduce and tSNE+kmeans are stochastic and give different results every time they are run. To get a better overview of the solutions, we need to run the methods multiple times. Here we run tSNE+kmeans clustering 10 times with \\(k = 3\\) (with perplexity = 10): tsne.res &lt;- scRNA.seq.funcs::tsne_mult(input.log, 3, 10) res &lt;- unique(do.call(rbind, tsne.res)) Exercise 9: Visualize the different clustering solutions using a heatmap. Then run tSNE+kmeans algorithm with \\(k = 2\\) or \\(k = 4\\) and see how the clustering looks like in these cases. Figure 17.7: Clustering solutions of tSNE+kmeans method after running it for 10 times and using \\(k=3\\) Figure 17.8: Clustering solutions of tSNE+kmeans method after running it for 10 times and using \\(k=2\\) Figure 17.9: Clustering solutions of tSNE+kmeans method after running it for 10 times and using \\(k=4\\) 17.5 SNN-Cliq Here we run SNN-cliq with te default parameters provided in the author’s example: distan &lt;- &quot;euclidean&quot; par.k &lt;- 3 par.r &lt;- 0.7 par.m &lt;- 0.5 # construct a graph scRNA.seq.funcs::SNN( data = t(input.log), outfile = &quot;snn-cliq.txt&quot;, k = par.k, distance = distan ) # find clusters in the graph snn.res &lt;- system( paste0( &quot;python snn-cliq/Cliq.py &quot;, &quot;-i snn-cliq.txt &quot;, &quot;-o res-snn-cliq.txt &quot;, &quot;-r &quot;, par.r, &quot; -m &quot;, par.m ), intern = TRUE ) cat(paste(snn.res, collapse = &quot;\\n&quot;)) ## input file snn-cliq.txt ## find 8 quasi-cliques ## merged into 2 clusters ## unique assign done snn.res &lt;- read.table(&quot;res-snn-cliq.txt&quot;) # remove files that were created during the analysis system(&quot;rm snn-cliq.txt res-snn-cliq.txt&quot;) Exercise 10: How can you characterize the solution identified by SNN-Cliq? Run SNN-Cliq algorithm with different values of k, r, m and distance, and see how the clustering looks like in these cases. 17.6 SINCERA As mentioned in the previous chapter SINCERA is based on hierarchical clustering. One important thing to keep in mind is that it performs a gene-level z-score transformation before doing clustering: # perform gene-by-gene per-sample z-score transformation dat &lt;- apply(input, 1, function(y) scRNA.seq.funcs::z.transform.helper(y)) # hierarchical clustering dd &lt;- as.dist((1 - cor(t(dat), method = &quot;pearson&quot;))/2) hc &lt;- hclust(dd, method = &quot;average&quot;) If the number of cluster is not known SINCERA can identify k as the minimum height of the hierarchical tree that generates no more than a specified number of singleton clusters (clusters containing only 1 cell) num.singleton &lt;- 0 kk &lt;- 1 for (i in 2:dim(dat)[2]) { clusters &lt;- cutree(hc, k = i) clustersizes &lt;- as.data.frame(table(clusters)) singleton.clusters &lt;- which(clustersizes$Freq &lt; 2) if (length(singleton.clusters) &lt;= num.singleton) { kk &lt;- i } else { break; } } cat(kk) ## 1 Exercise 11: Visualize the SINCERA results as a heatmap. How do the results compare to the other methods? What happens if you choose \\(k = 3\\)? Our answer: Figure 17.10: Clustering solutions of SINCERA method using \\(k=3\\) Exercise 12: Is using the singleton cluster criteria for finding k a good idea? 17.7 SEURAT Here we follow an example created by the authors of SEURAT. We had to introduce some modifications due to the errors produced by the original code: library(Seurat) # Create a SEURAT object d &lt;- new(&quot;seurat&quot;, raw.data = as.data.frame(log(patient.data + 1))) # Setup a SEURAT object d &lt;- setup( d, project = &quot;NBT&quot;, min.cells = 3, names.field = 2, names.delim = &quot;_&quot;, min.genes = 10, is.expr = 1 ) # Genes placed into 20 bins based on X-axis (average expression). # Y-axis is within-bin z-score of log(Variance/mean). d &lt;- mean.var.plot( d, y.cutoff = 2, x.low.cutoff = 2, fxn.x = expMean, fxn.y = logVarDivMean ) # Run a PCA using the variable genes as input d &lt;- pca(d, do.print = FALSE, pcs.store = 25) # Do 200 random samplings to find significant genes, # each time randomly permute 1% of genes. # This returns a &#39;p-value&#39; for each gene in each PC, # based on how likely the gene/PC score would have been observed by chance d &lt;- jackStraw( d, num.replicate = 200, do.print = FALSE, num.pc = 25 ) # Compare the distribution of P-values for each PC with a uniform distribution. # &#39;Significant&#39; PCs will have a strong enrichment of genes with low p-values pAll &lt;- d@jackStraw.empP pAll$Contig &lt;- rownames(pAll) pAll.l &lt;- melt(pAll, id.vars = &quot;Contig&quot;) colnames(pAll.l) &lt;- c(&quot;Contig&quot;, &quot;PC&quot;, &quot;Value&quot;) score.df &lt;- NULL score.thresh=1e-5 for (i in unique(pAll.l$PC)){ q &lt;- qqplot(pAll[, i], runif(1000), plot.it = FALSE) pc.score &lt;- prop.test( c( length(which(pAll[, i] &lt;= score.thresh)), floor(nrow(pAll) * score.thresh) ), c(nrow(pAll), nrow(pAll)) )$p.val if (length(which(pAll[, i] &lt;= score.thresh)) == 0) pc.score &lt;- 1 if(is.null(score.df)) score.df &lt;- data.frame(PC = i, Score = pc.score) else score.df &lt;- rbind(score.df, data.frame(PC = i, Score = pc.score)) } # There are no significant PCs: head(score.df) ## PC Score ## 1 PC1 0.4704864 ## 2 PC2 1.0000000 ## 3 PC3 1.0000000 ## 4 PC4 1.0000000 ## 5 PC5 1.0000000 ## 6 PC6 1.0000000 ndim &lt;- 2 # Project data on a 2D using tSNE d &lt;- run_tsne(d, dims.use = 1:ndim, max_iter = 2000) # Find clusters in the tSNE map d &lt;- DBclust_dimension( d, 1, 2, reduction.use = &quot;tsne&quot;, G.use = 8, set.ident = TRUE ) tsne.plot(d, pt.size = 1) Exercise 13: As you can see DBSCAN could find only one cluster. It is known that DBSCAN cannot cluster data sets well with large differences in densities, since the G.use parameter cannot then be chosen appropriately for all clusters. Try to change G.use to be able to find more than one cluster in the data. Note We found that in general SEURAT does not work well for small datasets (N &lt; 200 cells). For a comprehensive comparisons of the methods please look at the SC3 paper (Kiselev et al. 2016). References "],
["identification-of-important-genes.html", "18 Identification of important genes 18.1 Fitting the models 18.2 The Michaelis-Menten Equation 18.3 Right outliers 18.4 Validation of DE results 18.5 Comparing M3Drop to other methods", " 18 Identification of important genes library(scRNA.seq.funcs) library(M3Drop) library(limma) set.seed(1) One of the key differences between single-cell RNASeq and bulk RNASeq is the large number of dropouts (zero expression) for genes with even moderately high levels of average expression. These zeros violate assumptions made by many statistical tools used for bulk RNASeq, eg. Negative Binomial expression used by DESeq2, normality assumptions of correlation methods, or assumptions of few tied-ranks for many non-parametric tests. Some recent scRNASeq methods model a different dropout rate for each gene (eg. MAST, BASiCS) while other methods try to fit the relationship between expression level and dropout rate across genes for a specific application (eg. SCDE, ZIFA). We will be using our new package Michaelis-Menten Modelling of Dropouts (M3Drop) which specifically focuses on modelling and gaining biological insights from dropouts. For this section we will be working with the Usoskin et al data. It contains 4 cell types: NP = non-peptidergic nociceptors, PEP = peptidergic nociceptors, NF = neurofilament containing and TH = tyrosine hydroxylase containing neurons. usoskin1 &lt;- readRDS(&quot;usoskin/usoskin1.rds&quot;) dim(usoskin1) ## [1] 25334 622 table(colnames(usoskin1)) ## ## NF NP PEP TH ## 139 169 81 233 18.1 Fitting the models First we must normalize &amp; QC the dataset. M3Drop contains a built-in function for this which removes cells with few detected genes, removes undetected genes, and converts raw counts to CPM. uso_list &lt;- M3Drop::M3Drop_Clean_Data( usoskin1, labels = colnames(usoskin1), min_detected_genes = 2000, is.counts = TRUE ) Exercise 1: How many cells &amp; genes have been removed by this filtering? Do you agree with the 2000 detected genes threshold? 18.2 The Michaelis-Menten Equation The Michaelis-Menten (MM) Equation is the standard model of enzyme kinetics. We use it to model dropouts in single-cell RNASeq because most dropouts occur as a result of failing to be reverse-transcribed to sufficient levels. The details are omitted here, but in this model the probability that a transcript will not be found is given by \\[P_{dropout} = K/(K + S)\\] where \\(S\\) is the mRNA concentration in the cell (we will estimate this as average expression) and \\(K\\) is the Michaelis-Menten constant. Other models that have been proposed are: \\(P=Logistic(\\log(S))\\) used by SCDE (determining differential expression) and \\(P=e^{-\\lambda*S^2}\\) used by ZIFA (zero-inflated PCA). Now we will fit all three models to the normalized Usoskin data: models &lt;- M3Drop::M3Drop_Dropout_Models(uso_list$data) title(main = &quot;Usoskin&quot;) 18.3 Right outliers There are many outliers to the right of the fitted MM curve. Genes which are expressed at different levels in subpopulations of our cells will be shifted to the right of the curve. This happens because the MM curve is a convex function, whereas averaging dropout rate and expression is a linear function. K = 49.473 S_sim = 10^seq(from=-3, to=4, by=0.05) MM = 1-S_sim/(K+S_sim) plot(S_sim, MM, type=&quot;l&quot;, lwd=3, xlab=&quot;Expression&quot;, ylab=&quot;Dropout Rate&quot;, xlim=c(1,1000)) S1 = 10; P1 = 1-S1/(K+S1) # Expression &amp; dropouts for cells in condition 1 S2 = 750; P2 = 1-S2/(K+S2) # Expression &amp; dropouts for cells in condition 2 points(c(S1,S2),c(P1,P2), pch=16, col=&quot;grey85&quot;, cex=3) mix = 0.5; # proportion of population in condition 1 points(S1*mix+S2*(1-mix), P1*mix+P2*(1-mix), pch=16, col=&quot;grey35&quot;, cex=3) Note: add log=&quot;x&quot; to the plot call above to see how this looks on the log scale, which is used in M3Drop figures. Exercise 2: Produce the same plot as above with different expression levels (S1 &amp; S2) and/or mixtures (mix). We use M3Drop to identify significant outliers to the right of the MM curve. We also apply 1% FDR multiple testing correction: DE_genes &lt;- M3Drop::M3Drop_Differential_Expression( uso_list$data, mt_method = &quot;fdr&quot;, mt_threshold = 0.01 ) title(main = &quot;Usoskin&quot;) Check which of the known neuron markers are identified as DE: uso_markers &lt;- c(&quot;Nefh&quot;, &quot;Tac1&quot;, &quot;Mrgprd&quot;, &quot;Th&quot;, &quot;Vim&quot;, &quot;B2m&quot;, &quot;Col6a2&quot;, &quot;Ntrk1&quot;, &quot;Calca&quot;, &quot;P2rx3&quot;, &quot;Pvalb&quot;) rbind(uso_markers, uso_markers %in% DE_genes$Gene) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## uso_markers &quot;Nefh&quot; &quot;Tac1&quot; &quot;Mrgprd&quot; &quot;Th&quot; &quot;Vim&quot; &quot;B2m&quot; &quot;Col6a2&quot; &quot;Ntrk1&quot; ## &quot;TRUE&quot; &quot;TRUE&quot; &quot;TRUE&quot; &quot;TRUE&quot; &quot;TRUE&quot; &quot;FALSE&quot; &quot;FALSE&quot; &quot;TRUE&quot; ## [,9] [,10] [,11] ## uso_markers &quot;Calca&quot; &quot;P2rx3&quot; &quot;Pvalb&quot; ## &quot;TRUE&quot; &quot;TRUE&quot; &quot;TRUE&quot; 18.4 Validation of DE results We can also plot the expression levels of these genes to check they really are DE genes. M3Drop::M3Drop_Expression_Heatmap( DE_genes$Gene, uso_list$data, cell_labels = uso_list$labels, key_genes = uso_markers ) 18.5 Comparing M3Drop to other methods We can compare the genes identified as DE using M3Drop to those identified using other methods. Running differential expression methods which compare two groups at a time is slow for this dataset (6 possible pairs of groups x 15,708 genes) thus we have provided you with the output for DESeq. Load it using: DESeq_table &lt;- readRDS(&quot;usoskin/DESeq_table.rds&quot;) length(unique(DESeq_table$Gene)) ## [1] 2604 We will demonstrate some of the methods starting from the simplest one proposed by Brennecke et al., which identifies genes with significant variation above technical noise (ERCCs). To use the method, we first normalize for library size then calculate the mean and the square coefficient of variation (variation divided by the squared mean expression). A quadratic curve is fit to the relationship between these two variables for the ERCC spike-in (subject to just technical variation) then a chi-square test is used to find genes significantly above the curve. This has been provided for you as the Brennecke_getVariableGenes(counts, spikes) function. However, there are only 9 spike-ins detected in this dataset so we will use the entire dataset as spike-ins. In the figure below the red curve is the fitted technical noise model and the dashed line is the 95% CI. Pink dots are the genes with significant biological variability after multiple-testing correction. Since our dataset is relatively homogeneous only genes are identified as significantly variable. Brennecke_HVG &lt;- M3Drop::Brennecke_getVariableGenes( uso_list$data, fdr = 0.01, minBiolDisp = 0.5 ) length(Brennecke_HVG) ## [1] 1595 Exercise 3: Plot a heatmap of the expression of the HVGs and DESeq DE genes. Do they look differentially expressed? Exercise 4: How many of the known markers are identified by Brennecke &amp; DESeq? Finally, we can compare the overlaps between these three dataset. all.genes &lt;- unique( c( as.character(DESeq_table$Gene), Brennecke_HVG, as.character(DE_genes$Gene) ) ) venn.diag &lt;- vennCounts( cbind( all.genes %in% as.character(DESeq_table$Gene), all.genes %in% Brennecke_HVG, all.genes %in% as.character(DE_genes$Gene) ) ) limma::vennDiagram( venn.diag, names = c(&quot;DESeq&quot;, &quot;HVG&quot;, &quot;M3Drop&quot;), circle.col = c(&quot;magenta&quot;, &quot;blue&quot;, &quot;green&quot;) ) "],
["ordering-of-cells-according-to-pseudotime.html", "19 Ordering of cells according to pseudotime 19.1 TSCAN 19.2 monocle 19.3 Comparison of the methods 19.4 Expression of genes through time", " 19 Ordering of cells according to pseudotime library(TSCAN) library(M3Drop) library(monocle) set.seed(1) In many situations, one is studying a process where cells change continuously. This includes for example many differentiation processes taking place during development, where following a stimulus, cells will change from one cell-type to another. Ideally, we would like to monitor the expression levels of an individual cell over time. Unfortunately, such monitoring is not possible with scRNA-seq since the cell is lysed (destroyed) when the RNA is extracted. Instead, we must sample at multiple time-points and obtain snapshots of the gene expression profiles. Since some of the cells will proceed faster along the differentiation than others, each snapshot may contain cells at varying points along the developmental progression. We use statistical methods to order the cells along one or more trajectories which represent the underlying developmental trajectories, this ordering is referred to as “pseudotime”. In this chapter we will consider two different tools, Monocle and TSCAN for ordering cells according to their pseudotime development. To illustrate the methods we will be using a dataset on mouse embryonic development (Deng et al. 2014). The dataset consists of 268 cells from 10 different time-points of early mouse development. 19.1 TSCAN TSCAN combines clustering with pseudotime analysis. First it clusters the cells using mclust, which is based on a mixture of normal distributions. Then it builds a minimum spanning tree to connect the clusters together. The branch of this tree that connects the largest number of clusters is the main branch which is used to determine pseudotime. First we will try to use all genes to order the cells. deng &lt;- readRDS(&quot;deng/deng.rds&quot;) cellLabels &lt;- colnames(deng) procdeng &lt;- TSCAN::preprocess(deng) colnames(procdeng) &lt;- 1:268 dengclust &lt;- TSCAN::exprmclust(procdeng, clusternum = 10) TSCAN::plotmclust(dengclust) dengorderTSCAN &lt;- TSCAN::TSCANorder(dengclust, orderonly = F) pseudotime_order_tscan &lt;- as.character(dengorderTSCAN$sample_name) We can also examine which timepoints have been assigned to each state: cellLabels[dengclust$clusterid == 1] ## [1] &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; colours &lt;- rainbow(n = 10) # red = early, violet = late plot( cellLabels[as.numeric(pseudotime_order_tscan)], xlab=&quot;Pseudotime Order&quot;, ylab=&quot;Timepoint&quot;, col = colours[as.numeric(cellLabels[as.numeric(pseudotime_order_tscan)])], pch = 16 ) Exercise 1 Compare results for different numbers of clusters (clusternum). 19.2 monocle Monocle skips the clustering stage of TSCAN and directly builds a minimum spanning tree to connect all cells. Monocle then identifies the longest path in this tree to determine pseudotime. If the data contains diverging trajectories (i.e. one cell type differentiates into two different cell-types), monocle can identify alternative long paths in the tree using the argument num_paths. Each of the resulting forked paths is defined as a separate cell state, thus num_paths = 2 will identify three different cell states. Unfortunately, Monocle does not work when all the genes are used, so we must carry out feature selection. First, we use M3Drop: m3dGenes &lt;- as.character( M3Drop::M3Drop_Differential_Expression(deng, suppress.plot = T)$Gene ) d &lt;- deng[which(m3dGenes %in% rownames(deng)),] d &lt;- d[!duplicated(rownames(d)),] Now run monocle: pd &lt;- as.data.frame(as.numeric(as.character(cellLabels))) names(pd) &lt;- &quot;timepoint&quot; pd &lt;- new(&quot;AnnotatedDataFrame&quot;, data=pd) fd &lt;- as.data.frame(rownames(d)) names(fd) &lt;- &quot;gene&quot; fd &lt;- new(&quot;AnnotatedDataFrame&quot;, data=fd) colnames(d) &lt;- 1:dim(d)[2] rownames(d) &lt;- 1:dim(d)[1] rownames(pd) &lt;- colnames(d) rownames(fd) &lt;- rownames(d) dCellData &lt;- monocle::newCellDataSet(d, phenoData = pd, featureData = fd) dCellData &lt;- monocle::setOrderingFilter(dCellData, 1:length(m3dGenes)) dCellDataSet &lt;- monocle::reduceDimension(dCellData, pseudo_expr = 1) dCellDataSet &lt;- monocle::orderCells(dCellDataSet, reverse = F, num_paths = 1) monocle::plot_spanning_tree(dCellDataSet) # Store the ordering pseudotime_monocle &lt;- data.frame( Timepoint = phenoData(dCellDataSet)$timepoint, pseudotime = phenoData(dCellDataSet)$Pseudotime, State=phenoData(dCellDataSet)$State ) rownames(pseudotime_monocle) &lt;- 1:268 pseudotime_order_monocle &lt;- rownames(pseudotime_monocle[order(pseudotime_monocle$pseudotime), ]) We can again compare the inferred pseudotime to the known sampling timepoints. plot( pseudotime_monocle$pseudotime, pseudotime_monocle$Timepoint, xlab=&quot;Pseudotime&quot;, ylab=&quot;Timepoint&quot;, col = colours[pseudotime_monocle$Timepoint], pch = 16 ) 19.3 Comparison of the methods How do the trajectories inferred by TSCAN and Monocle compare? matched_ordering &lt;- match( pseudotime_order_tscan, pseudotime_order_monocle ) timepoint_ordered &lt;- pseudotime_monocle[order(pseudotime_monocle$pseudotime), 1] plot( matched_ordering, xlab = &quot;Monocle Order&quot;, ylab = &quot;TSCAN Order&quot;, col = colours[timepoint_ordered], pch = 16 ) 19.4 Expression of genes through time Each package also enables the visualization of expression through pseudotime. TSCAN colnames(deng) &lt;- 1:268 TSCAN::singlegeneplot( deng[rownames(deng) == &quot;Obox6&quot;, ], dengorderTSCAN ) Monocle monocle::plot_genes_in_pseudotime( dCellDataSet[fData(dCellDataSet)$gene == &quot;Obox6&quot;,], color_by = &quot;timepoint&quot; ) Exercise 2: Repeat the exercise using a subset of the genes, e.g. the set of highly variable genes that can be obtained using M3Drop::Brennecke_getVariableGenes References "],
["differential-expression-de-analysis.html", "20 Differential Expression (DE) analysis 20.1 Bulk RNA-seq 20.2 Single cell RNA-seq 20.3 scRNA-seq synthetic data 20.4 Single gene expression 20.5 Poisson-Beta distribution 20.6 Sample size 20.7 Dropout noise 20.8 Dispersion noise", " 20 Differential Expression (DE) analysis 20.1 Bulk RNA-seq One of the most common types of analyses when analyzing bulk RNA-seq data is to identify differentially expressed genes. By comparing the genes that change between two conditions, e.g. mutant and wild-type or stimulated and unstimulated, it is possible to characterize the molecular mechanisms underlying the change. Several different methods, e.g. DESeq2 and edgeR, have been developed for bulk RNA-seq. Moreover, there are also extensive datasets available where the RNA-seq data has been validated using RT-qPCR. These data can be used to benchmark DE finding algorithms. 20.2 Single cell RNA-seq In contrast to the bulk RNA-seq in scRNA-seq we usually do not have a defined set of experimental conditions, but instead, as was shown in the previous chapter (17) we can identify the cell groups by using the unsupervised clustering approach. Once the groups have been identified one can find differentially expressed genes by either looking at the differencies in variance between the groups (like the Kruskal-Wallis test implemented in SC3), or by comparing gene expression between clusters in a pairwise manner. In the following chapter we will mainly consider tools developed for the comparison of the two groups of cells. 20.3 scRNA-seq synthetic data One advantage of working with single-cell data is that there is a reliable, analytically tractable mathematical model for the expression levels, the Poisson-Beta distribution. Importantly, the Poisson-Beta distribution has strong experimental support, and it provides a good fit to scRNA-seq data. In this module, we first discuss the Poisson-Beta distribution. We then use the model to generate synthetic data which we can use to compare different DE finding algorithms. In the final section we investigate a real scRNA-seq dataset. 20.4 Single gene expression library(scRNA.seq.funcs) set.seed(1) For single-cell data, the analytically tractable stochastic bursting model provides a good fit. Thus, we can use it to generate realistic data. We start by generating samples from one gene: s &lt;- scRNA.seq.funcs::PoiBeta(100, 2, 3) We then plot the results as a histogram: hist(s, freq = FALSE, xlab = &quot;# transcripts&quot;, main = &quot;Transcript distribution&quot;) Figure 20.1: Distribution of read counts for a single genes across 100 cells based on the Poisson-Beta model The probability mass function of the Poisson-Beta distribution is challenging to work with since it involves special functions. However, the mean and variance can be calculated as: \\(\\mu = k\\cdot a/(a+b)\\) \\(\\sigma^2 = k^2\\cdot a\\cdot b/((a+b+1)\\cdot(a+b)^2)\\) 20.5 Poisson-Beta distribution There are three regimes of the Poisson-Beta distribution and they are determined by the values of the parameters \\(a\\) and \\(b\\). When \\(a&lt;1\\) and \\(b&lt;1\\) we have a bimodal distribution with one mode at 0 and the other at \\(k\\), when \\(a&lt;1\\) and \\(b&gt;1\\) we have a monotonically decreasing distribution and otherwise we have a unimodal distribution with a mode at \\(ka/(a+b)\\). par(mfrow=c(3,1)) hist(scRNA.seq.funcs::PoiBeta(100, .2, .3), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(0, 0, 1, 1/4), breaks = seq(0, 120, 10)) hist(scRNA.seq.funcs::PoiBeta(100, .2, 3), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(0,1,0,1/4), breaks = seq(0, 120, 10)) hist(scRNA.seq.funcs::PoiBeta(100, 2, .3), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(1, 0, 0, 1/4), breaks = seq(0, 120, 10)) Figure 20.2: Different distributions of read counts for a single genes across 100 cells based on the Poisson-Beta model corresponding to different paramete sets Exercise 1: Vary the parameters a, b and k to explore how the location and shape of the distribution changes. 20.6 Sample size The difficulty in determining the parameters of the distribution also depends on the sample size. In the example below, it is not clear if the distribution is bimodal when only 10 samples are drawn. hist(scRNA.seq.funcs::PoiBeta(10, .6, 1.2, 10), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(1, 0, 0, 1/4), breaks = seq(0, 20, 1)) hist(scRNA.seq.funcs::PoiBeta(10, .6, 1.2, 50), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(0, 1, 0, 1/4), breaks = seq(0, 20, 1), add = TRUE) Figure 20.3: Effect of sampling size on the distribution of read counts based on the Poisson-Beta model Exercise 2: Modify the number of samples (i.e. cells) drawn to explore how difficult it is to correctly infer the correct shape. 20.7 Dropout noise The stochastic bursting model only captures the biological variability. In practice there will also be experimental variability. We model the noise as drop-outs, i.e. we assume that there is a small probality that each transcript is lost. For gene \\(i\\) and cell \\(j\\) it is assumed that the probability of loosing the transcript is given by \\(p_d = \\mu/(d+\\mu)\\), where \\(\\mu\\) is the mean expression level of the gene and \\(d\\) is a drop-out parameter. Thus, the probability of drop-outs monotonically decreases as the mean expression level increases. To visualize the impact of the drop-outs on a sample, we can tune the drop-out parameter: par(mfrow=c(3,1)) hist(scRNA.seq.funcs::PoiBeta(100, 2, 3, 100, 1), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(1, 0, 0, 1/4), ylim = c(0, .08), xlim = c(0, 120)) hist(scRNA.seq.funcs::PoiBeta(100, 2, 3, 100, 10), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(0, 1, 0, 1/4), ylim = c(0, .08), xlim = c(0, 120)) hist(scRNA.seq.funcs::PoiBeta(100, 2, 3, 100, 100), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(0, 0, 1, 1/4), ylim = c(0, .08), xlim = c(0, 120)) Figure 20.4: Effect of dropouts on the distribution of read counts based on the Poisson-Beta model Exercise 3: Explore the different parameter regimes for the same drop-out rate. Do you think that we are more sensitive to drop-outs in any specific regime? 20.8 Dispersion noise Another example of noise is under- or over-dispersion. This can be modelled using a single parameter multiplying the parameters \\(a\\) and \\(b\\) in the Poisson-Beta distribution by a scalar \\(s\\). We can see that the mean is left unchanged while the variance is inversely proportional to \\(s\\). s &lt;- 10^(-3:3) k &lt;- 100 a &lt;- 2 b &lt;- 3 par(mfrow=c(1,1)) plot(s, k*a*s/(a*s + b*s), log = &quot;x&quot;, col = &quot;red&quot;, ylim = c(0, 50), ylab = &quot;Moments&quot;) points(s, k*a*s*b*s/((a*s + b*s)^2*(a*s + b*s + 1)), col = &quot;blue&quot;) Figure 20.5: The mean and the variance of the distribution of read counts based on the Poisson-Beta model To illustrate the effect of the dispersion parameter on the distribution consider: par(mfrow=c(3,1)) hist(scRNA.seq.funcs::PoiBeta(100, 2, 3, 100), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(1, 0, 0, 1/4), ylim = c(0, .05), xlim = c(0, 120)) hist(scRNA.seq.funcs::PoiBeta(100, 2/10, 3/10, 100), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(0, 1, 0, 1/4), ylim = c(0, .05), xlim = c(0, 120)) hist(scRNA.seq.funcs::PoiBeta(100, 2*10, 3*10, 100), freq = FALSE, xlab = &quot;# transcripts&quot;, col = rgb(0, 0, 1, 1/4), ylim = c(0, .05), xlim = c(0, 120)) Figure 20.6: Effect of dispersion on the distribution of read counts based on the Poisson-Beta model Exercise 4: Explore what happens when you have both drop-outs and under/over-dispersion. Can the effects be deconvoluted? "],
["de-in-a-synthetic-dataset.html", "21 DE in a synthetic dataset 21.1 Dataset 21.2 DE in scRNA-seq 21.3 Kolmogorov-Smirnov test 21.4 Performance of KS test 21.5 DESeq2 21.6 SCDE 21.7 Comparison of the methods 21.8 Beyond changes in the mean", " 21 DE in a synthetic dataset library(scRNA.seq.funcs) library(DESeq2) library(scde) library(ROCR) library(limma) set.seed(1) 21.1 Dataset We start by generating samples using the Poisson-Beta distribution, using 100 genes from 50 cells. To simulate the second experimental condition we select one of the three parameters for each gene and modify it by multiplying by a normally distributed random factor. nGenes &lt;- 1e2 nCells &lt;- 50 mult &lt;- 2^(rnorm(nGenes, 0, 2)) synData &lt;- scRNA.seq.funcs::GeneratePoiBetaSamples( ks = 10^(rnorm(nGenes, 3, .5)), as = 10^(rnorm(nGenes, -1, .5)), bs = 10^(rnorm(nGenes, 0, .5)), mult, nGenes, nCells ) g &lt;- synData$sample1 g2 &lt;- synData$sample2 21.2 DE in scRNA-seq For bulk data, each gene is represented by a single value and to identify DEGs we need to identify those genes where the difference in expression between two conditions is sufficiently large. Replicates are needed for us to be able to assess the fold-change as well as its significance. For single-cell data, the situation is more complicated; instead of comparing two means we are faced with the task of comparing two probability distributions. There are many different functions available for comparing two probability distributions (e.g. Total variation distance and Kullback-Leibler divergence), and since they emphasize different features, they have different properties. To establish a ground-truth, we arbitrarily assign genes where one of the parameters has changed by more than a factor of 4 as being true positives. Remaining genes are considered not significantly changed. changedGenes &lt;- abs(log2(mult)) &gt; 2 changedGenesInds &lt;- which(changedGenes) notChangedGenesInds &lt;- which(abs(log2(mult)) &lt;= 2) 21.3 Kolmogorov-Smirnov test The types of test that are easiest to work with are non-parametric ones. The most commonly used non-parametric test is the Kolmogorov-Smirnov test (KS-test) and we can use it to compare the distributions for each gene in the two conditions. The KS-test quantifies the distance between the empirical cummulative distributions of the expression of each gene in each of the two populations. It is sensitive to changes in mean experssion and changes in variability. However it assumes data is continuous and may perform poorly when data contains a large number of identical values (eg. zeros). INSERT THE FIGURE FROM THE WIKIPEDIA PAGE? nGenes &lt;- nrow(g) pVals &lt;- rep(1, nGenes) for (i in 1:nGenes) { res &lt;- ks.test(g[i,], g2[i,]) # Bonferroni correction pVals[i] &lt;- res$p.value*nGenes } Using the standard p-value cut-off .05, we can find out how many genes that were called as significantly different. ksChangedGenes &lt;- which(pVals &lt; 0.05) ksNotChangedGenes &lt;- which(pVals &gt;= 0.05) cat(changedGenesInds) ## 4 11 14 15 24 28 31 35 39 54 55 56 58 61 67 68 70 75 83 84 87 92 93 95 97 99 cat(ksChangedGenes) ## 13 28 31 35 40 55 56 61 67 84 87 97 cat(intersect(changedGenesInds, ksChangedGenes)) ## 28 31 35 55 56 61 67 84 87 97 21.4 Performance of KS test The genes identified by the KS-test differs substantially from the ground truth. Instead of considering the absolute number of identified genes, it is often more informative to consider False positive rate (FPR) and the True positive rate (TPR). The False positive rate is defined as FPR = FP/(FP + TP) and the True positive rate as TPR = TP/(TP + FN), where FP is the number of false positives, TN the number of true negatives, TP the number of true negatives and FN the number of false negatives. tp &lt;- length(intersect(changedGenesInds, ksChangedGenes)) fn &lt;- length(intersect(changedGenesInds, which(pVals &gt;= .05))) fp &lt;- length(intersect(notChangedGenesInds, ksChangedGenes)) tn &lt;- length(intersect(notChangedGenesInds, which(pVals &gt;= .05))) tpr &lt;- tp/(tp + fn) fpr &lt;- fp/(fp + tn) cat(c(tpr, fpr)) ## 0.3846154 0.02702703 As you can see, the p-value cut-off .05 results in a low TPR and a high FPR. That is, the test has failed to identify many of the genes that were truly changed and many of the changed genes were not detected. Clearly, there is a trade-off between TPR and FPR. If one is willing to accept a higher FPR, then one will be able to achieve a higher TPR. The relationship between FPR and TPR is typically shown as a receiver-operator-characteristic (ROC) curve. To generate and plot the ROC curve, we need to change the p-value cut-off. To facilitate the plotting, we use the package “ROCR” pred &lt;- ROCR::prediction(pVals, as.numeric(abs(log2(mult)) &lt;= 2)) perf &lt;- ROCR::performance(pred, &quot;tpr&quot;, &quot;fpr&quot;) ROCR::plot(perf) Figure 21.1: Different distributions of read counts for a single genes across 50 cells based on the Poisson-Beta model corresponding to different paramete sets Often we are interested in comparing several ROC curves. To carry out such a comparison, we need to summarize the entire curve using only one scalar value. This can be achieved by calculating the area under the ROC curve (AUROC). Since an ROC curve has to stay above the diagonal (why?) the AUROC will be between .5 and 1. aucObj &lt;- ROCR::performance(pred, &quot;auc&quot;) aucObj@y.values[[1]] ## [1] 0.7837838 Exercise: Compare the AUC values when you change some of the parameters in the analysis, e.g. number of cells, number of genes, threshold for considering a gene differentially expressed, distribution of parameter values, distribution of fold-changes. What factors make it easy or hard to identify differentially expressed genes? 21.5 DESeq2 One could still apply bulk DE methods to scRNA-seq data. One of the most popular methods for differential expression analysis for bulk RNA-Seq data is DESeq2. DESeq2 estimates the variability of each gene using a quadratic relationship between mean expression and variability across all samples fit using Bayesian statistics. It then tests for a difference in mean expression across groups based on a negative binomial distribution. Let’s try it out on our synthetic dataset: cnts &lt;- cbind(g, g2) cond &lt;- factor( c( rep(&quot;A&quot;, ncol(g)), rep(&quot;B&quot;, ncol(g2)) ) ) # object construction, add a pseudo-count of 1 to make DESeq work dds &lt;- DESeq2::DESeqDataSetFromMatrix( cnts + 1, DataFrame(cond), ~ cond) dds &lt;- DESeq2::DESeq(dds) resDESeq &lt;- results(dds) Check the performance of DESeq2: pValsDESeq &lt;- resDESeq$padj predDESeq &lt;- prediction(pValsDESeq, as.numeric(abs(log2(mult)) &lt;= 2)) perfDESeq &lt;- performance(predDESeq, &quot;tpr&quot;, &quot;fpr&quot;) ROCR::plot(perfDESeq) Figure 21.2: Different distributions of read counts for a single genes across 50 cells based on the Poisson-Beta model corresponding to different paramete sets aucObjDESeq &lt;- performance(predDESeq, &quot;auc&quot;) aucObjDESeq@y.values[[1]] ## [1] 0.8503119 Exercise: Based on the AUC-value, does DESeq or the KS-test seem more accurate? Can you find a parameter regime where the ranking is changed? 21.6 SCDE There are yet much fewer methods available for scRNA-seq data than for bulk data, but one better known method is SCDE. SCDE uses Bayesian statistics to fit a zero-inflated negative binomial distribution to the expression of each gene and tests for differences in mean expression level between groups. We can use it on the synthetic data: cnts &lt;- cbind(g, g2) cnts &lt;- apply( cnts, 2, function(x) { storage.mode(x) &lt;- &#39;integer&#39; return(x) } ) cond &lt;- factor( c( rep(&quot;A&quot;, ncol(g)), rep(&quot;B&quot;, ncol(g2)) ) ) names(cond) &lt;- 1:length(cnts[1, ]) colnames(cnts) &lt;- 1:length(cnts[1, ]) o.ifm &lt;- scde::scde.error.models( counts = cnts, groups = cond, n.cores = 1, threshold.segmentation = TRUE, save.crossfit.plots = FALSE, save.model.plots = FALSE, verbose = 0, min.size.entries = 20 ) priors &lt;- scde::scde.expression.prior( models = o.ifm, counts = cnts, length.out = 400, show.plot = FALSE) resSCDE &lt;- scde::scde.expression.difference( o.ifm, cnts, priors, groups = cond, n.randomizations = 100, n.cores = 1, verbose = 0) # Convert Z-scores into 2-tailed p-values pValsSCDE &lt;- pnorm(abs(resSCDE$cZ), lower.tail = FALSE) * 2 pValsSCDE &lt;- p.adjust(pValsSCDE, method = &quot;bonferroni&quot;) Exercise: Calculate an AUROC value and compare to the other methods. Our answer: ## [1] 0.7827443 21.7 Comparison of the methods From the above analyses it is clear that none of the three methods (KS, DESeq2 and SCDE) is able to reliably find the majority of the DE genes. A popular strategy in this situation is to combine two or more methods, in the hope that genes that were identified by more than method are more likely to be true positives. par(mfrow = c(1, 1)) limma::vennDiagram( vennCounts( cbind( changedGenes, pValsDESeq &lt; .05, pValsSCDE &lt; .05, pVals &lt; .05 ) ), names = c(&quot;Ground truth&quot;, &quot;DESeq2&quot;, &quot;SCDE&quot;, &quot;KS-test&quot;), circle.col = c(&quot;magenta&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;red&quot;)) allChangedInds &lt;- intersect( which(pValsDESeq &lt; .05), intersect(which(pValsSCDE &lt; .05), which(pVals &lt; .05) ) ) tpAll &lt;- length(intersect(changedGenesInds, allChangedInds)) fnAll &lt;- length(intersect(changedGenesInds, setdiff(1:1e3, allChangedInds))) fpAll &lt;- length(intersect(notChangedGenesInds, allChangedInds)) tnAll &lt;- length(intersect(notChangedGenesInds, setdiff(1:1e3, allChangedInds))) tprAll &lt;- tpAll / (tpAll + fnAll) fprAll &lt;- fpAll / (fpAll + tnAll) cat(c(tprAll, fprAll)) ## 0.1538462 0 The more stringent approach results in a lower FPR at the cost of a lower TPR. Exercise: Calculate the TPR and FPR for the case when we require two out of three methods to agree. 21.8 Beyond changes in the mean In the realm of single-cell analyses, differential expression is no longer restricted to changes in the mean. As we saw in the previous chapter, it is possible to change the shape of the distribution without changing its mean. Exercise: Repeat the analysis above, but this time only change the variance, but not the mean. To generate the synthetic data, use the following command: nGenes &lt;- 1e2 nCells &lt;- 50 mult &lt;- 2^(rnorm(nGenes, 0, 2)) synData &lt;- scRNA.seq.funcs::GeneratePoiBetaSamples( ks = 10^(rnorm(nGenes, 3, .5)), as = 10^(rnorm(nGenes, -1, .5)), bs = 10^(rnorm(nGenes, 0, .5)), mult, nGenes, nCells, meanFixed = TRUE ) g &lt;- synData$sample1 g2 &lt;- synData$sample2 Our answer: ## [1] 0.8460339 ## [1] 0.4982175 ## [1] 0.5011141 Which method performs the best? Why do some methods perform differently for this scenario? What are the properties of the genes that are identified as DE? "],
["de-in-a-real-dataset.html", "22 DE in a real dataset 22.1 Introduction 22.2 KS-test 22.3 DESeq2 22.4 SCDE 22.5 Comparison of the methods 22.6 Visualisation", " 22 DE in a real dataset library(scRNA.seq.funcs) library(DESeq2) library(scde) library(ROCR) library(limma) set.seed(1) 22.1 Introduction The main advantage of using synthetic data is that we have full control over all aspects of the data, and this facilitates the interpretation of the results. However, the transcriptional bursting model is unable to capture the full complexity of a real scRNA-seq dataset. Next, we are going to analyze the difference between the transcriptomes of the 2-cell and the 4-cell state of a mouse embryo as described by Biase et al. For our purposes you need to download the biase into the biase folder in your working directory. We can then look at the data: biase &lt;- as.matrix( read.table( &quot;biase/biase_et_al_2cell_4cell_fpkm.tsv&quot; ) ) # keep those genes that are expressed in at least 6 cells biase &lt;- biase[rowSums(biase &gt; 0) &gt; 5, ] pheatmap::pheatmap( log2(biase + 1), scale = &quot;column&quot;, cutree_cols = 2, kmeans_k = 100, show_rownames = FALSE ) As you can see, the cells cluster well by their developmental stage. We can now use the same methods as before to obtain a list of differentially expressed genes. Because SCDE is very slow here we will only use a subset of genes. You should not do that with your real dataset, though. Here we do it just for demostration purposes: biase &lt;- biase[sample(1:nrow(biase), 500), ] 22.2 KS-test pVals &lt;- rep(1, nrow(biase)) for (i in 1:nrow(biase)) { res &lt;- ks.test( biase[i, 1:20], biase[i , 21:40] ) # Bonferroni correction pVals[i] &lt;- res$p.value * nrow(biase) } 22.3 DESeq2 cond &lt;- factor( c( rep(&quot;cell2&quot;, 20), rep(&quot;cell4&quot;, 20) ) ) dds &lt;- DESeq2::DESeqDataSetFromMatrix( round(biase) + 1, colData = DataFrame(cond), design = ~ cond ) dds &lt;- DESeq2::DESeq(dds) resDESeq &lt;- DESeq2::results(dds) pValsDESeq &lt;- resDESeq$padj 22.4 SCDE cnts &lt;- apply( biase, 2, function(x) { storage.mode(x) &lt;- &#39;integer&#39; return(x) } ) names(cond) &lt;- 1:length(cnts[1, ]) colnames(cnts) &lt;- 1:length(cnts[1, ]) o.ifm &lt;- scde::scde.error.models( counts = cnts, groups = cond, n.cores = 1, threshold.segmentation = TRUE, save.crossfit.plots = FALSE, save.model.plots = FALSE, verbose = 0, min.size.entries = 2 ) priors &lt;- scde::scde.expression.prior( models = o.ifm, counts = cnts, length.out = 400, show.plot = FALSE ) resSCDE &lt;- scde::scde.expression.difference( o.ifm, cnts, priors, groups = cond, n.randomizations = 100, n.cores = 1, verbose = 0 ) # Convert Z-scores into 2-tailed p-values pValsSCDE &lt;- pnorm(abs(resSCDE$cZ), lower.tail = FALSE) * 2 pValsSCDE &lt;- p.adjust(pValsSCDE, method = &quot;bonferroni&quot;) 22.5 Comparison of the methods vennDiagram( vennCounts( cbind( pVals &lt; 0.05, pValsDESeq &lt; 0.05, pValsSCDE &lt; 0.05 ) ), names = c(&quot;KS-test&quot;, &quot;DESeq2&quot;, &quot;SCDE&quot;), circle.col = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;) ) Exercise 1: How does this Venn diagram correspond to what you would expect based on the synthetic data? 22.6 Visualisation To further characterize the list of genes, we can calculate the average fold-changes and compare the ones that were called as differentially expressed to the ones that were not. cell2 &lt;- biase[, 1:20] cell4 &lt;- biase[, 21:40] ksGenesChangedInds &lt;- which(pVals&lt;.05) deSeqGenesChangedInds &lt;- which(pValsDESeq&lt;.05) scdeGenesChangedInds &lt;- which(pValsSCDE&lt;.05) ksGenesNotChangedInds &lt;- which(pVals&gt;=.05) deSeqGenesNotChangedInds &lt;- which(pValsDESeq&gt;=.05) scdeGenesNotChangedInds &lt;- which(pValsSCDE&gt;=.05) meanFoldChange &lt;- rowSums(cell2)/rowSums(cell4) nGenes &lt;- nrow(cell2) par(mfrow=c(2,1)) hist(log2(meanFoldChange[ksGenesChangedInds]), breaks = -50:50, freq = FALSE, xlab = &quot;# fold-change&quot;, col = rgb(1, 0, 0, 1/4), ylim = c(0, .4), xlim = c(-8, 8)) hist(log2(meanFoldChange[deSeqGenesChangedInds]), breaks = -50:50, freq = FALSE, xlab = &quot;# fold-change&quot;, col = rgb(0, 0, 1, 1/4), ylim = c(0, .4), xlim = c(-8, 8)) Exercise 2: Create the histogram of fold-changes for SCDE. Compare the estimated fold-changes between the different methods? What do the genes where they differ have in common? 22.6.1 Volcano plots A popular method for illustrating the difference between two conditions is the volcano plot which compares the magnitude of the change and the significance. par(mfrow=c(2,1)) plot(log2(meanFoldChange[ksGenesNotChangedInds]), -log10(pVals[ksGenesNotChangedInds]/nGenes), xlab = &quot;mean expression change&quot;, ylab = &quot;-log10(P-value), KS-test&quot;, ylim = c(0, 15), xlim = c(-12, 12)) points(log2(meanFoldChange[ksGenesChangedInds]), -log10(pVals[ksGenesChangedInds]/nGenes), col = &quot;red&quot;) plot(log2(meanFoldChange[deSeqGenesNotChangedInds]), -log10(pValsDESeq[deSeqGenesNotChangedInds]), xlab = &quot;mean expression change&quot;, ylab = &quot;-log10(P-value), DESeq2&quot;, ylim = c(0, 15), xlim = c(-12, 12)) points(log2(meanFoldChange[deSeqGenesChangedInds]), -log10(pValsDESeq[deSeqGenesChangedInds]), col = &quot;blue&quot;) 22.6.2 MA-plot Another popular method for illustrating the difference between two conditions is the MA-plot, in which the data has been transformed onto the M (log ratios) and A (mean average) scale: par(mfrow=c(2,1)) plot(log2(rowMeans(cell2[ksGenesNotChangedInds,])), log2(meanFoldChange[ksGenesNotChangedInds]), ylab = &quot;mean expression change&quot;, xlab = &quot;mean expression&quot;, ylim = c(-9, 9)) points(log2(rowMeans(cell2[ksGenesChangedInds,])), log2(meanFoldChange[ksGenesChangedInds]), col = &quot;red&quot;) plot(log2(rowMeans(cell2[deSeqGenesNotChangedInds,])), log2(meanFoldChange[deSeqGenesNotChangedInds]), ylab = &quot;mean expression change&quot;, xlab = &quot;mean expression&quot;, ylim = c(-9, 9)) points(log2(rowMeans(cell2[deSeqGenesChangedInds,])), log2(meanFoldChange[deSeqGenesChangedInds]), col = &quot;blue&quot;) Exercise 3: The volcano and MA-plots for the SCDE are missing - can you generate them? Compare to the synthetic data, what do they tell you about the properties of the genes that have changed? 22.6.3 Heatmap of DE genes Finally, we can plot heatmaps of the genes that were called as DE by the intersection of the three. allChangedInds &lt;- intersect(which(pValsDESeq&lt;.05), intersect(which(pValsSCDE&lt;.05), which(pVals&lt;.05))) pheatmap::pheatmap(log2(1 + cbind(cell2, cell4)[allChangedInds,]), cutree_cols = 2, show_rownames = FALSE) Exercise 4: Create heatmaps for the genes that were detected by at least 2/3 methods. "],
["advanced-exercises.html", "23 Advanced exercises", " 23 Advanced exercises For the final part of the course we provide you with a few open-ended question. The goal of these questions is to stimulate new ideas about what types of analyses that you can carry out with scRNA-seq data. We have collected published scRNA-seq datasets and stored the expression matrices as .rds files which you can download Treutlein et al Deng et al Pollen et al, alt Pollen Usoskin et al, alt Usoskin, another Usoskin Klein et al Here are some suggestions for questions that you can explore: SC3 uses a different method compared to SCDE and DESeq2 to compare several groups at once to identify marker genes. Can you use SCDE or DESeq2 to compare the clusters from the above datasets to find marker genes? How does this set of genes differ from the one obtained by SC3? Both the Pollen et al and the Usoskin et al come in more than one version. The only difference between the files are the cell labels. The different datasets have been clustered at different granularities. Use SC3 and other clustering tools to explore the different granularities. Do you think that there is stronger support for one choice of granularity over another? How can you best motivate one choice over another? Does the interpretation of the data change depending on the choice of \\(k\\)? Can you identify some other choice of \\(k\\) that the authors did not suggest? In addition to identifying differences in expression between different cell types, we are also interested in finding differences in regulatory interactions. One way of characterizing regulatory interactions is through correlation coefficients. Can you identify differences in regulation between different clusters of cells in any of the above datasets? "],
["resources.html", "24 Resources 24.1 scRNA-seq protocols 24.2 scRNA-seq analysis tools", " 24 Resources 24.1 scRNA-seq protocols SMART-seq2 CELL-seq Drop-seq UMI STRT-Seq 24.2 scRNA-seq analysis tools Normalization: RUVSeq BASiCS scLVM DE and pathway analysis: D3E SCDE Hard clustering: SC3 pcaReduce tSNE+kmeans SNN-Cliq SINCERA Finding important genes: Bernecke method M3D Pseudo-time analysis: Monocle Wanderlust embeddr "],
["references.html", "25 References", " 25 References "]
]
